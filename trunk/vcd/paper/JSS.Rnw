\documentclass[article]{jss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{thumbpdf}

%% almost as usual
\author{David Meyer\\Wirtschaftsuniversit\"at Wien \And 
        Achim Zeileis\\Wirtschaftsuniversit\"at Wien \And 
        Kurt Hornik\\Wirtschaftsuniversit\"at Wien}
\title{The Strucplot Framework:\\ Visualizing Multi-way Contingency
  Tables with \pkg{vcd}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{David Meyer, Achim Zeileis, Kurt Hornik} %% comma-separated
\Shorttitle{The Strucplot Framework} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
This paper describes the `strucplot' framework for the visualization of
multi-way contingency tables. Strucplot displays include hierarchical
conditional plots such as mosaic, association, and sieve plots, and
can be combined into more complex, specialized plots for visualizing
conditional independence, GLMs, and the results of
independence tests. The frameworks' modular design allows
flexible customization of the plots' graphical appearance, including 
shading, labeling, spacing, and legend, by means of \underline{gr}aphical
\underline{ap}pearance \underline{con}trol (`grapcon') functions. 
The framework is provided by the \proglang{R} package \pkg{vcd}.
}

\Keywords{contingency tables, mosaic plots, association plots, sieve plots, 
categorical data, independence, conditional independence, HSV, HCL,
residual-based shading, \pkg{grid}, \proglang{R}}
\Plainkeywords{contingency tables, mosaic plots, association plots,
  sieve plots, categorical data, independence, 
  conditional independence, HSV, HCL, residual-based shading, grid, R}

%\VignetteIndexEntry{The Strucplot Framework: Visualizing Multi-way Contingency Tables With package vcd}
%\VignetteDepends{vcd}
%\VignetteKeywords{contingency tables, mosaic plots, association plots, sieve plots, R, categorical data, independence, conditional independence, HSV, HCL, residual-based shading, grid}
%\VignettePackage{vcd}

%% publication information
%% NOTE: This needs to filled out ONLY IF THE PAPER WAS ACCEPTED.
%% If it was not (yet) accepted, leave them commented.
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  David Meyer\\
  Department of Information Systems and Process Management\\
  E-mail: \email{David.Meyer@wu-wien.ac.at}\\
  URL: \url{http://wi.wu-wien.ac.at/~meyer/}\\

  Achim Zeileis\\
  Department of Statistics and Mathematics\\
  E-mail: \email{Achim.Zeileis@wu-wien.ac.at}\\
  URL: \url{http://www.ci.tuwien.ac.at/~zeileis/}\\

  Kurt Hornik\\
  Department of Statistics and Mathematics\\
  E-mail: \email{Kurt.Hornik@wu-wien.ac.at}\\
  URL: \url{http://www.wu-wien.ac.at/cstat/hornik/}\\

  Wirtschaftsuniversit\"at Wien\\
  Augasse 2--6
  1090 Wien, Austria\\
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

\SweaveOpts{engine=R,eps=TRUE,height=6,width=7,results=hide,fig=FALSE,echo=TRUE}
\setkeys{Gin}{width=0.7\textwidth}

<<preliminaries,echo=FALSE,results=hide>>=
set.seed(1071)
library(vcd)
data(Titanic)
data(HairEyeColor)
data(PreSex)
data(Arthritis)
art <- xtabs(~Treatment + Improved, data = Arthritis)
@

\newcommand{\var}[1]{\textit{\texttt{#1}}}
\newcommand{\data}[1]{`\texttt{#1}'}
\newcommand{\class}[1]{\textsf{#1}}
%% \code without `-' ligatures
\def\nohyphenation{\hyphenchar\font=-1 \aftergroup\restorehyphenation}
\def\restorehyphenation{\hyphenchar\font=`-}
{\catcode`\-=\active%
  \global\def\code{\bgroup%
    \catcode`\-=\active \let-\codedash%
    \Rd@code}}
\def\codedash{-\discretionary{}{}{}}
\def\Rd@code#1{\texttt{\nohyphenation#1}\egroup}

\newcommand{\codefun}[1]{\code{#1()}}


%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section[Introduction]{Introduction}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.


In order to explain multi-dimensional categorical data, statisticians
typically look for (conditional) independence structures. Whether the
task is purely exploratory or model-based, techniques such as mosaic and
association plots offer good support for visualization. Both have been
extended over the last two decades, and implementations exist in many
statistical environments. 
Both graphical methods visualize aspects of (possibly higher-dimensional)
contingency tables. A \emph{mosaic plot} \citep{vcd:Hartigan+Kleiner:1984} is basically 
an area-proportional visualization of (typically, observed) frequencies, composed
of tiles (corresponding to the cells) created by recursive
vertical and horizontal splits of a square. Thus, the area of each tile
is proportional to the corresponding cell entry \emph{given} the
dimensions of previous splits. An \emph{association plot} \citep{vcd:Cohen:1980}
visualizes the standardized deviations of observed frequencies from
those expected under a certain independence hypothesis.
Each cell is represented by a rectangle that has
(signed) height proportional to the residual and width proportional
to the square root of the expected counts, 
so that the area of the box is proportional
to the difference in observed and expected frequencies.

Over the years, extensions to these techniques were mainly focused on
five aspects:

\begin{enumerate}
\item Varying the shape of bar plots and mosaic displays to yield, e.g.,
  double-decker plots \citep{vcd:hofmann:2001}, spine plots, or
  spinograms \citep{vcd:hofmann+theus}.
\item Using residual-based shadings to visualize log-linear models
  \citep{vcd:Friendly:1994,vcd:Friendly:2000} and significance of
  statistical tests \citep{vcd:Meyer+Zeileis+Hornik:2003,vcd:Zeileis+Meyer+Hornik:2005}.
\item Using pairs plots and trellis-like layouts for marginal, conditional and
  partial views \citep{vcd:Friendly:1999}.
\item Adding direct user interaction, allowing quick exploration and
  modification of the visualized models 
  \citep{vcd:Unwin+Hawkins+Hofmann:1996,vcd:Theus:2003}.
\item Providing a modular and flexible implementation to easily allow
  user extensions \citep{vcd:Meyer+Zeileis+Hornik:2003}.
\end{enumerate}

\noindent Current implementations of mosaic displays can be found,
e.g., for \proglang{SAS} \citep{vcd:SAS:2005}, \proglang{ViSta} \citep{vcd:young:1996}, 
\proglang{MANET} \citep{vcd:Unwin+Hawkins+Hofmann:1996},
\proglang{Mondrian} \citep{vcd:Theus:2003},
\proglang{R} \citep{vcd:R:2005}, and \proglang{S-PLUS} \citep{vcd:SPLUS:2005}. 
Table \ref{tab:compare} gives an overview of the available functionality in these systems.

\begin{table}[h]
  \centering
  \begin{tabular}{|l|c|c|c|c|c|}
    \hline
                             & \proglang{SAS} & \proglang{S-PLUS} & \proglang{R} & \pkg{ViSta} & \pkg{MANET}/\pkg{Mondrian}\\\hline
    Basic functionality      &  $\times$  &   $\times$    & $\times$ &   $\times$   & $\times$\\
    Shape                    &     &        & $\times$ &       & $\times$\\
    Residual-based shadings  &  $\times$  &        & $\times$ &   $\times$   & ($\times$)\\
    Conditional Views        &  $\times$  &        & $\times$ &       & $\times$\\
    Interaction              &     &        &   &   $\times$   & $\times$\\
    Extensible Design        &     &        & $\times$ &       &  \\\hline
  \end{tabular}
  \caption{Comparison of current software environments.}
  \label{tab:compare}
\end{table}

Figures \ref{fig:arthritis} to \ref{fig:titanic} illustrate some of these
extensions (the code is shown in Appendix \ref{sec:code}). 
Figure \ref{fig:arthritis} shows the results from a double-blind clinical trial
investigating a new treatment for rheumatoid arthritis, using an
extended mosaic plot with residual-based shading based on the
maximum statistic: clearly, the new treatment is effective. Figure
\ref{fig:ucbadmissions} visualizes the well-known UCB admissions data
by the means of a conditional association plot. The panels show the
residuals from a conditional independence model (independence of gender
and admission, given department), stratified by department. Clearly,
the situation in department A (more women/less men accepted than
would be expected under the null) causes the rejection of the
hypothesis of conditional independence. Figure \ref{fig:presex}
illustrates the conditional independence of premarital and
extramarital sex, given gender and marital status. The Chi-squared
test of independence rejects the null hypothesis: possibly, because
too many men who had premarital sex also had extramarital sex?
Finally, Figure \ref{fig:titanic} visualizes the `Survival on the Titanic' 
data using a double-decker plot. Here, a binary response (survival to the disaster)
shall be explained by other factors (class, gender, and age). The blue
boxes represent the proportion of survived passengers in a particular
stratum. The proportions of saved women and children are indeed higher
than those of men, but they clearly decrease from the 1st to the 3rd class. In
addition, the proportion of saved men in the 1st class is higher than
in the others.

\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}[p]
\begin{center}
<<Arthritis,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
mosaic(art, gp = shading_max, split_vertical = TRUE)
@
\caption{Mosaic plot for the \data{Arthritis} data.}
\label{fig:arthritis}
\end{center}
\end{figure}

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<UCBAdmissions,fig=TRUE,echo=FALSE,height=6,width=10,results=hide>>=
cotabplot(UCBAdmissions, panel = cotab_assoc, shade = TRUE, legend = FALSE)
@
\caption{Conditional association plot for the \data{UCBAdmissions} data.}
\label{fig:ucbadmissions}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}[p]
\begin{center}
<<PreSex,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
mosaic(PreSex, condvars = c(1, 4), shade = TRUE)
@
\caption{Mosaic plot for the \data{PreSex} data.}
\label{fig:presex}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<Titanic,fig=TRUE,echo=FALSE,height=6,width=8,results=hide>>=
doubledecker(Survived ~ ., data = Titanic, labeling_args = 
             list(set_varnames = c(Sex = "Gender")))
@
\caption{Double-decker plot for the \data{Titanic} data.}
\label{fig:titanic}
\end{center}
\end{figure}

This paper describes the strucplot framework provided by the \pkg{vcd} package
for the \proglang{R} system and environment for statistical computing
and graphics, available from the Comprehensive \proglang{R} Archive Network (\url{http://cran.r-project.org/}).
The framework integrates displays such as mosaic, association, and
sieve plots by their unifying property of being 
flat representations of contingency tables.
These basic plots, as well as specialized displays for conditional
independence, can be used both for exploratory visualization and
model-based analysis. Exploratory techniques include specialized displays for
the bivariate case, as well as pairs and trellis plot-like displays for
higher-dimensional tables. Model-based tools include 
methods suitable for the visualization of 
conditional independence tests (including permutation tests), as well
as for the visualization of particular GLMs (logistic regression,
log-linear models). Additionally, two of the frameworks' further strengths are its
flexibility and extensibility: graphical appearance aspects such as shading,
labeling, and spacing are modularized by means of `graphical
appearance functions', allowing fine-granular customization and
user-level extensions.

The remainder of the paper is organized as follows. In
Section \ref{sec:strucplot}, we give an overview of the strucplot
framework, describing the hierarchy of the main components and the
basic functionality. 
In Section \ref{sec:shading}, we demonstrate how
(residual-based) shadings support the visualization of log-linear models and
the results of independence tests. Also, we explain step-by-step how
the concepts of generating functions and graphical appearance control
functions can be combined to provide a flexible customization of
complex graphical displays as created by the strucplot framework.
Sections \ref{sec:labeling} and \ref{sec:spacing} discuss in detail the labeling
and spacing features, respectively, before Section \ref{sec:conclusion}
concludes the work.

\section[The strucplot framework]{The strucplot framework}
\label{sec:strucplot}

The strucplot framework in the \proglang{R} package \pkg{vcd}, used for visualizing
multi-way contingency tables, integrates techniques such as
mosaic displays, association plots, and sieve plots. The main idea is to visualize
the tables' cells arranged in rectangular form. For multi-way tables,
the variables are nested into rows and columns using recursive
conditional splits, given the margins. The result is a 
`flat' representation that can be visualized in
ways similar to a two-dimensional table.
This principle defines a class of conditional displays which allows
for granular control of graphical appearance aspects, including:

\begin{itemize}
\item the content of the tiles
\item the split direction for each dimension
\item the graphical parameters of the tiles' content
\item the spacing between the tiles
\item the labeling of the tiles
\end{itemize}

The strucplot framework is highly modularized: Figure \ref{fig:struc}
shows the hierarchical relationship between the various components. 
On the lowest level, there are several groups of workhorse and 
parameter functions that directly or indirectly influence the final
appearance of the plot. These are examples of `graphical appearance control'
(`grapcon') functions. They are created by generating functions
(`grapcon generators'), allowing
flexible parameterization and extensibility (Figure \ref{fig:struc}
only shows the generators). The generator names
follow the naming convention \code{\emph{group\_foo}()},  
where (\code{\emph{group}}) reflects the group the
generators belong to (strucplot core, labeling,
legend, shading, or spacing). The workhorse functions (created by 
\code{struc\_\emph{foo}()}, 
\code{labeling\_\emph{foo}()}, and \code{legend\_\emph{foo}()}) 
directly produce graphical output (i.e., ``add ink to the canvas''), whereas
the parameter functions
(created by \code{spacing\_\emph{foo}()} and \code{shading\_\emph{foo}()}) compute
graphical parameters used by the others. The grapcon functions returned by 
\code{struc\_\emph{foo}()} implement the core functionality, creating the tiles and their
content.  On the second level of the framework, a suitable combination
of the low-level grapcon functions (or, alternatively, corresponding generating functions)
is passed as ``hyperparameters'' to \codefun{strucplot}.
This central function 
sets up the graphical layout using grid viewports (see Figure \ref{fig:layout}),
and coordinates the specified core, labeling, shading, and spacing functions to produce 
the plot. On the third level, we provide
several convenience functions such as \codefun{mosaic},
\codefun{sieve}, \codefun{assoc}, and \codefun{doubledecker} which 
interface \codefun{strucplot} through sensible parameter defaults
and support for model formulae. Finally, on the fourth
level, there are `related' \pkg{vcd} functions (such as \codefun{cotabplot}
and the \codefun{pairs} methods for table objects) 
arranging collections of plots of the strucplot 
framework into more complex displays (e.g., by means of panel functions).

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{struc}
    \caption{Components of the strucplot framework.}
    \label{fig:struc}
  \end{center}
\end{figure}

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}[h]
\begin{center}
<<vcdlayout,fig=TRUE,echo=FALSE,width=6,height=6>>=
    pushViewport(vcd:::vcdViewport(legend = T, mar =4))
    seekViewport("main")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("main", gp = gpar(fontsize = 20))
    seekViewport("sub")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("sub", gp = gpar(fontsize = 20))
    seekViewport("plot")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("plot", gp = gpar(fontsize = 20))
    seekViewport("legend")
    grid.text("legend", rot = 90, gp = gpar(fontsize = 20))
    grid.rect(gp = gpar(lwd = 3))
    seekViewport("legend_sub")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[F]", gp = gpar(fontsize = 20))
    seekViewport("legend_top")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[E]", gp = gpar(fontsize = 20))
    seekViewport("margin_top")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("margin_top", gp = gpar(fontsize = 20))
    seekViewport("margin_bottom")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("margin_bottom", gp = gpar(fontsize = 20))
    seekViewport("margin_right")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("margin_right", rot = 90, gp = gpar(fontsize = 20))
    seekViewport("margin_left")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("margin_left", rot = 90, gp = gpar(fontsize = 20))
    seekViewport("corner_top_left")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[A]", gp = gpar(fontsize = 20))
    seekViewport("corner_top_right")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[B]", gp = gpar(fontsize = 20))
    seekViewport("corner_bottom_left")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[C]", gp = gpar(fontsize = 20))
    seekViewport("corner_bottom_right")
    grid.rect(gp = gpar(lwd = 3))
    grid.text("[D]", gp = gpar(fontsize = 20))
@ 
\caption{Viewport layout for strucplot displays with their names. [A] =
  ``corner\_top\_left'', [B] = ``corner\_top\_right'', 
  [C] = ``corner\_bottom\_left'', [D] = ``corner\_bottom\_right'', [E]
  = ``legend\_top'', [F] = ``legend\_sub''.}
\label{fig:layout}
\end{center}
\end{figure}
\setkeys{Gin}{width=0.7\textwidth}

\subsection{Mosaic, association, and sieve plots}

As an example, consider the \data{HairEyeColor} 
data containing two polytomous variables (hair and eye color), 
as well as one (artificial) dichotomous variable (gender). The
`flattened' contingency table can be obtained using the
\codefun{structable} function (quite similar to \codefun{ftable} in
base \proglang{R}, but allowing the specification of split directions):

<<structable,results=verbatim>>=
(hec <- structable(Eye ~ Sex + Hair, data = HairEyeColor))
@

Let us first visualize the contingency table by means of a mosaic plot.
% \citep{vcd:Hartigan+Kleiner:1984} which is basically 
% an area-proportional visualization of (typically, observed) frequencies, composed
% of tiles (corresponding to the cells) created by recursive
% vertical and horizontal splits of a square. Thus, the area of each tile
% is proportional to the corresponding cell entry \emph{given} the
% dimensions of previous splits. 
Figure \ref{fig:observed} depicts the effect of

<<Observed>>=
mosaic(hec)
@

\noindent equivalent to

<<Observed2>>=
mosaic(~ Sex + Eye + Hair, data = HairEyeColor)
@

%\setkeys{Gin}{width=0.75\textwidth}
\begin{figure}[p]
\begin{center}
<<Observedfig,fig=TRUE,echo=FALSE,height=6>>=
<<Observed>>
@
\caption{Mosaic plot for the \data{HairEyeColor} data.}
\label{fig:observed}
\end{center}
\end{figure}

\noindent The small bullets indicate zero entries in the corresponding
cell. Note that in contrast to, e.g.,  \codefun{mosaicplot} in base
\proglang{R}, the default split direction and level ordering in all strucplot
displays correspond to the textual representation.
It is also possible to visualize the expected values instead of the
observed values (see Figure \ref{fig:expected}):

<<Expected>>=
mosaic(hec, type = "expected")
@

\begin{figure}[p]
\begin{center}
<<Expectedfig,fig=TRUE,echo=FALSE,height=6>>=
<<Expected>>
@
\caption{Mosaic plot for the \data{HairEyeColor} data (expected values).}
\label{fig:expected}
\end{center}
\end{figure}
%\setkeys{Gin}{width=0.7\textwidth}

\noindent In order to compare observed and expected values,
a sieve plot \citep{vcd:riedwyl+schuepbach:1994} 
could be used (see Figure \ref{fig:sieve}):

<<sieve>>=
sieve(hec)
@

\begin{figure}[h]
\begin{center}
<<sievefig,fig=TRUE,echo=FALSE>>=
<<sieve>>
@
\caption{Sieve plot for the \data{HairEyeColor} data visualizing simultaneously
  observed and expected values.}
\label{fig:sieve}
\end{center}
\end{figure}

\noindent Alternatively, we can directly inspect the residuals. 
The Pearson residuals (standardized deviations of observed from expected values) 
are preferably visualized using association
plots \citep{vcd:Cohen:1980}. In contrast to \codefun{assocplot} in
base \proglang{R}, \pkg{vcd}'s \codefun{assoc}
function scales to more than two variables (see Figure \ref{fig:residuals}):

<<Residuals>>=
assoc(hec, compress = FALSE)
@

\begin{figure}[p]
\begin{center}
<<Residualsfig,fig=TRUE,echo=FALSE,width=6, height=10>>=
<<Residuals>>
@
\caption{Association plot for the \data{HairEyeColor} data.}
\label{fig:residuals}
\end{center}
\end{figure}

\noindent The \code{compress} argument keeps distances between tiles
equal for better comparison.

For both mosaic plots and association plots, 
the splitting of the tiles can be controlled using the
\code{split\_vertical} argument (default: alternating splits starting
with a vertical one). 

<<echo=FALSE>>=
options(width=60)
@ 

<<split1>>=
mosaic(hec, split_vertical = c(TRUE, FALSE, TRUE), 
labeling_args = list(abbreviate = c(Eye = 3)))
@

<<echo=FALSE>>=
options(width=70)
@ 

\noindent (Note that \code{hec}, a \class{structable} object, already includes a
splitting information which simply gets overloaded in this example.) 
For compatibility with \codefun{mosaicplot} in base \proglang{R},
the \codefun{mosaic} function also allows the use of a \code{"direction"} 
argument taking a vector of \code{"h"} and
\code{"v"} characters (see Figure \ref{fig:split}):

<<split2>>=
mosaic(hec, direction = c("v","h","v"))
@

\begin{figure}[p]
\begin{center}
<<splitfig,fig=TRUE,echo=FALSE,width=7,height=7>>=
<<split1>>
@
\caption{Mosaic plot for the \data{HairEyeColor} data---alternative splitting.}
\label{fig:split}
\end{center}
\end{figure}

By a suitable combination of splitting, spacing, and
labeling settings, the functions provided by the strucplot framework
can be customized in a quite flexible way. For example, 
\codefun{doubledecker} is simply a wrapper for 
\codefun{mosaic}, setting the right defaults. 
Figure \ref{fig:doubledecker} shows a doubledecker plot of
the \data{Titanic} data, explaining the probability of survival (`survived') by age, given
sex, given class. It is created by:

<<doubledecker1>>=
doubledecker(Titanic)
@

\noindent equivalent to:

<<doubledecker2>>=
doubledecker(Survived ~ Class + Sex + Age, data = Titanic)
@

\begin{figure}[h]
\begin{center}
<<doubledeckerfig,fig=TRUE,echo=FALSE>>=
<<doubledecker1>>
@
\caption{Doubledecker plot for the \data{Titanic} data.}
\label{fig:doubledecker}
\end{center}
\end{figure}

\subsection{Conditional and partial views}

So far, we have visualized full tables. For objects of class \class{table},
conditioning on levels (i.e., choosing a table subset for fixed levels
of the conditioning variable(s)) is simply done by indexing.
However, subsetting \class{structable} objects is more restrictive 
because of their inherent conditional structure. Since the variables
on both the row and the columns side are nested, 
conditioning is only possible ``outside-in'':

<<subsetting,results=verbatim>>=
hec
hec["Male",]
hec[c("Male", "Brown"),]
hec["Male","Green"]
@ 

\noindent Now, there are several ways for visualizing 
conditional independence structures. The ``brute force'' method is to
draw separate plots for the strata. The following example compares 
the association between hair and eye color, given gender, by using
subsetting on the flat table and \pkg{grid}'s viewport 
framework to visualize the two groups besides each other:

<<Variables>>=
pushViewport(viewport(layout = grid.layout(ncol = 2)))

pushViewport(viewport(layout.pos.col = 1))
mosaic(hec["Male"], margins = c(left = 2.5, top = 2.5, 0), sub = "Male", newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.col = 2))
mosaic(hec["Female"], margins = c(top = 2.5, 0), sub = "Female", newpage = FALSE)
popViewport(2)
@

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<Variablesfig,fig=TRUE,echo=FALSE,height=6,width=12>>=
<<Variables>>
@
\caption{Two mosaic displays put side-by-side, visualizing the 
distribution of hair and eye color, given gender. The marginal
distribution of `Sex' cannot be seen.}
\label{fig:parttable}
\end{center}
\end{figure}
\setkeys{Gin}{width=0.7\textwidth}

\noindent Note the use of the \code{margins} argument: it takes a
vector with up to four values whose unnamed components are recycled,
but ``overruled'' by the named arguments. Thus, in the example, only
the top margin is set to 2 lines, and all other to 0.
This idea applies to almost all
vectorized arguments in the strucplot framework (with
\code{split\_vertical} as a prominent exception).

Since mosaic displays are ``conditional plots'' by definition, we can
also use one single mosaic for stratified plots.
The formula interface of \codefun{mosaic} allows the
specification of conditioning variables (see Figure \ref{fig:conditioning}):

<<Conditioning>>=
mosaic(~ Hair + Eye | Sex, data = hec, split_vertical = TRUE, keep_aspect_ratio = FALSE)
@

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<Conditioningfig,fig=TRUE,echo=FALSE,width=12>>=
<<Conditioning>>
@
\caption{Mosaic plot again visualizing the 
distribution of hair and eye color, given gender, this time using a
single mosaic plot. In contrast to Figure \ref{fig:parttable}, this
plot also visualizes the marginal distribution of `Sex'.}
\label{fig:conditioning}
\end{center}
\end{figure}
\setkeys{Gin}{width=0.7}

\noindent The effect of using this kind of formula is that
conditioning variables are permuted ahead of the the conditioned variables
in the table, and that \codefun{spacing\_conditional} is used as
default to better
distinguish conditioning from conditioned dimensions.
This spacing uses equal space between tiles of conditioned variables,
and increasing space between tiles of conditioning variables. In
addition, we release the fixed aspect ratio to get less distorted margins.

The \codefun{cotabplot} function does a much better job on this task:
it arranges stratified strucplot displays 
in a lattice-like layout, conditioning on variable \emph{levels}.
The plot in Figure \ref{fig:cotabplot} shows hair and eye color, given sex:

<<cotabplot>>=
cotabplot(~ Hair + Eye | Sex, data = hec, panel_args = list(margins = 3), labeling = labeling_left(clip = FALSE))
@

\setkeys{Gin}{width=\textwidth}
\begin{figure}[h]
\begin{center}
<<cotabplotfig,fig=TRUE,echo=FALSE,height=6,width=11>>=
<<cotabplot>>
@
\caption{Conditional table plot for the \data{HairEyeColor} data,
  again visualizing the distribution of hair and eye color, given
  gender, using separate mosaic displays like the `manual' plot 
  in Figure \ref{fig:parttable}.}
\label{fig:cotabplot}
\end{center}
\end{figure}
\setkeys{Gin}{width=0.7\textwidth}

\noindent The \code{labeling\_args} argument modifies the labels'
appearance: here, to be left-aligned and unclipped
(see Section \ref{sec:labeling}).

Another high-level function for visualizing conditional independence
models are the \codefun{pairs} methods for table and structable objects.
In contrast to \codefun{cotabplot} which conditions on variables,
the \codefun{pairs} methods create pairwise views of the table. 
The function produces, by default, a plot matrix 
having strucplot displays in the off-diagonal panels, and
the variable names (optionally, with univariate statistics) in the diagonal cells. 
Figure \ref{fig:pairs} shows a pairs display with mosaic plots visualizing mutual 
independence in the lower triangle,
association plots for the same in the upper triangle, and bar charts in the diagonal.

<<pairs>>=
pairs(hec, lower_panel = pairs_assoc, space = 0.3, 
      diag_panel_args = list(rot = -45, just_leveltext = c("left","bottom")))
@

%\setkeys{Gin}{width=\textwidth}
\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}[h]
\begin{center}
<<pairsfig,fig=TRUE,echo=FALSE,width=8,height=8>>=
<<pairs>>
@
\caption{Pairs plot for the \data{HairEyeColor} data.}
\label{fig:pairs}
\end{center}
\end{figure}
\setkeys{Gin}{width=0.7\textwidth}

\noindent (The labels of the variables are to be read from left to
right and from top to bottom.) In plots produced by \codefun{pairs}, 
each panel's row and column define two variables $X$ and $Y$ used for the
specification of four different types of independence: pairwise,
total, conditional, and joint. The pairwise mosaic
matrix shows bivariate marginal relations between $X$ and $Y$, collapsed over all
other variables. The total independence mosaic matrix shows mosaic
plots for mutual independence, i.e., for marginal and conditional independence
among all pairs of variables. The conditional
independence mosaic matrix shows mosaic plots for marginal
independence of $X$ and $Y$, given all other variables. The joint independence
mosaic matrix shows mosaic plots for joint independence of all
pairs ($X$, $Y$) of variables from the others.

Since the matrix is symmetric, the upper and lower parts can
independently be used to display different 
types of independence models, or different strucplots displays
(mosaic, association, or sieve plots).
The available panel functions (\codefun{pairs\_assoc}, 
\codefun{pairs\_mosaic}, and \codefun{pairs\_sieve}) 
are simple wrappers to \codefun{assoc}, 
\codefun{mosaic}, and \codefun{sieve}, respectively. 
Obviously, seeing patterns in strucplot matrices 
becomes increasingly difficult with
higher dimensionality. Therefore, this plot is typically used with a suitable 
residual-based shading (see Section \ref{sec:shading}).


\subsection{Interactive plot modifications}

All strucplot core functions are supposed to produce conditional hierarchical
plots by the means of nested viewports, corresponding to the provided splitting
information. Thus, at the end of the plotting, each tile is associated with
a particular viewport. Each of those viewports has to be
conventionally named, enabling other strucplot modules, in particular the
labeling functions, to access specific tiles after they have been
plotted. The naming convention for the viewports is:

\begin{center}
\code{cell:\emph{Variable1}=\emph{Level1},\emph{Variable2}=\emph{Level2}} \dots
\end{center}

\noindent Clearly, these names depend on the splitting.
The following example shows how to access parts of the plot after it has
been drawn (see Figure \ref{fig:afterplot}):

<<viewportnames>>=
mosaic(~ Hair + Eye, data = hec, pop = FALSE)

seekViewport("cell:Hair=Blond")
grid.rect(gp = gpar(col = "red", lwd = 4))

seekViewport("cell:Hair=Blond,Eye=Blue")
grid.circle(r = 0.2, gp = gpar(fill = "cyan"))
@ 

\noindent Note that the viewport tree is removed by
default. Therefore, the \texttt{pop} argument has to be set to
\texttt{FALSE} when viewports shall be accessed. 

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}[h]
\begin{center}
<<viewportnamesfig,fig=TRUE,echo=FALSE>>=
<<viewportnames>>
@
\caption{Adding elements to a mosaic plot after drawing.}
\label{fig:afterplot}
\end{center}
\end{figure}

In addition to the viewports, the main graphical elements get names
following a similar construction method. This allows to change
graphical parameters of plot elements \emph{after} 
the plotting (see Figure \ref{fig:changeplot}):

<<changeplot,results=verbatim>>=
assoc(Eye ~ Hair, data = hec, pop = FALSE)
getNames()[1:6]
grid.edit("rect:Hair=Blond,Eye=Blue", gp = gpar(fill = "red"))
@ 

%% code-chunk reuse does not work with parameter changing
\begin{figure}[h]
\begin{center}
<<changeplotfig,fig=TRUE,echo=FALSE>>=
x <- tab <- margin.table(HairEyeColor, 1:2)
x[] <- "light gray"
x["Blond","Blue"] <- "Red"
assoc(tab, gp = gpar(fill = x))
@
\caption{Changing graphical parameters of elements after drawing.}
\label{fig:changeplot}
\end{center}
\end{figure}


\section{Residual-based shadings}
\label{sec:shading}


Unlike other graphics functions in base \proglang{R}, the strucplot framework 
allows almost full control over the graphical parameters of all plot elements. In
particular, in association plots, mosaic plots, and sieve plots, 
the user can modify the graphical appearance of each tile individually. 
Built on top of this functionality, the
framework supplies a set of shading functions choosing colors
appropriate for the visualization of log-linear models.
The tiles' graphical parameters are set using the \code{gp} argument
of the functions of the strucplot framework. This argument basically expects an object
of class \class{gpar} whose components are arrays of the same shape 
(length and dimensionality) as the data table (see Section \ref{sec:gp}). 
For convenience, however, the user can also
supply a specialized graphical appearance control (``grapcon'') 
function that computes such an object given a vector of
residuals, or, alternatively, a generating function that takes
certain arguments and returns such a grapcon function (see Section
\ref{sec:shadingcustom}). We provide several shading functions, including
support for both HSV and HCL colors, and the
visualization of significance tests (see Section \ref{sec:overview}).

\subsection{Specifying graphical parameters of strucplot displays}
\label{sec:gp}

As an example, consider the \data{UCBAdmissions} data. 
In the table aggregated over departments, we
would like to highlight the (incidentally wrong) impression that there
were too many male students accepted compared to the presumably
discriminated female students (see Figure \ref{fig:ucb}):

<<ucb,results=verbatim>>=
(ucb <- margin.table(UCBAdmissions, 1:2))

(fill_colors <- matrix(c("dark cyan","gray","gray","dark magenta"), ncol = 2))

mosaic(ucb, gp = gpar(fill = fill_colors, col = 0))
@

\begin{figure}[h]
\begin{center}
<<ucbfig,fig=TRUE,echo=FALSE>>=
<<ucb>>
@

\caption{Mosaic plot for the \data{UCBAdmissions} data with highlighted cells.}
\label{fig:ucb}
\end{center}
\end{figure}

\noindent As the example shows, we create a fourfold table 
with appropriate colors (dark cyan for admitted male students and dark
magenta for rejected female students) and supply them to the \code{fill} component 
of the \class{gpar} object passed to the \code{gp} argument of \codefun{mosaic}. 
For visual clarity, we additionally hide the tiles' borders by setting the \code{col} 
component to 0 (white).

If the parameters specified in the \class{gpar} object are ``incomplete'',
they will be recycled along the last splitting
dimension. In the following example based on the \data{Titanic} data, 
we will highlight all cells corresponding to survived
passengers (see Figure \ref{fig:recycling}):

<<recycling>>=
mosaic(Titanic, gp = gpar(fill = c("gray","dark magenta")), 
                spacing = spacing_highlighting,
                labeling_args = list(abbreviate = c(Age = 3), rep = c(Survived = FALSE))
      )
@

\noindent Note that \codefun{spacing\_highlighting} sets the spaces
between tiles in the last dimension to 0. The \code{labeling\_args} 
argument ensures that labels do not overlap (see Section \ref{sec:labeling}).

\begin{figure}[h]
\begin{center}
<<recyclingfig,fig=TRUE,echo=FALSE>>=
<<recycling>>
@
\caption{Recycling of parameters, used for highlighting the survived
  passengers in the \data{Titanic} data.}
\label{fig:recycling}
\end{center}
\end{figure}

\subsection{Customizing residual-based shadings}
\label{sec:shadingcustom}

This flexible way of specifying graphical parameters is the basis for a suite of
shading functions that modify the tiles' appearance with respect to a vector of 
residuals, resulting from deviations of observed from expected
frequencies under a given log-linear model. 
The idea is to visualize at least sign and absolute size of the residuals, but some
shadings, additionally, indicate overall significance. One particular
shading, the maximum shading, even allows to identify those cells that
cause the rejection of the null hypothesis.

Conceptually, the strucplot framework offers three alternatives to
add residual-based shading to plots:

\begin{enumerate}
\item Precomputing the graphical parameters (e.g., fill colors),
  encapsulating them into an object of class
  \class{gpar} as demonstrated in the previous section, and
  passing this object to the \code{gp} argument.
\item Providing a grapcon function to the \code{gp} argument that 
  takes residuals as input and returns an object as described in
  alternative 1.
 \item Providing a grapcon \emph{generating} function (`grapcon generator') 
  taking parameters and returning a function as described in alternative~2.
\end{enumerate}

\noindent For each of these approaches, we will demonstrate the
necessary steps to obtain a binary shading that visualizes the sign of
the residuals by a corresponding 
fill color (for simplicity, we will treat 0 as positive).

\subsubsection*{Alternative 1: Precomputed \class{gpar} object}

The first method is precomputing the graphical parameters ``by
hand''. We will use `light blue' color for positive and `light salmon'
color for negative residuals (see Figure \ref{fig:binary}):

<<shading1,results=verbatim>>=
expected <- independence_table(ucb)
(residuals <- (ucb - expected)  / sqrt(expected))

(shading1_obj <- ifelse(residuals > 0, "lightblue", "lightsalmon"))

mosaic(ucb, gp = gpar(fill = shading1_obj))
@ 

\begin{figure}[h]
\begin{center}
<<shading1fig,fig=TRUE,echo=FALSE>>=
<<shading1>>
@ 
\caption{Binary shading visualizing the sign of the residuals.}
\label{fig:binary}
\end{center}
\end{figure}

\subsubsection*{Alternative 2: Grapcon function}

For implementing alternative 2, we need to create a `shading function'
that computes \class{gpar} objects from
residuals. For that, we can just reuse the code from the previous step:

<<shading2>>=
shading2_fun <- function(res) gpar(fill = ifelse(res > 0, "lightblue", "lightsalmon"))
@ 

\noindent To create a mosaic display with binary shading, 
it now suffices to specify the data table along with
\codefun{shading2\_fun}:

<<shading3>>=
mosaic(ucb, gp = shading2_fun)
@ 

\noindent \codefun{mosaic} internally calls
\codefun{strucplot} which computes the residuals from the specified
independence model (total independence by default), passes them to
\codefun{shading2\_fun}, and uses the \class{gpar} object returned 
to finally create the plot.

Our \codefun{shading2\_fun} function might be useful, 
but can still be improved: the hard-wired colors should be
customizable. We cannot
simply extend the argument list to include, e.g., 
a \code{fill = c("lightblue", "lightsalmon")} argument because
\codefun{strucplot} will neither know how to handle it, nor let us
change the defaults. In fact, the interface of shading functions is fixed,
they are expected to take exactly one argument: a table of residuals. 
This is where generating functions (alternative 3) come
into play. 

\subsubsection*{Alternative 3: Grapcon generator}

We simply wrap our grapcon shading function in another 
function that takes all additional arguments it needs to use, possibly
preprocesses them, and returns the actual shading function. This returned
function will have access to the parameters since in \proglang{R}, nested
functions are lexically scoped. Thus, the grapcon generator
returns (`creates') a `parameterized' shading function with the minimal standard interface
\codefun{strucplot} requires. The following example shows the necessary
extensions for our running example:

<<shading3>>=
shading3a_fun <- function(col = c("lightblue", "lightsalmon")) {
  if (length(col) != 2) stop("Need exactly two colors!")
  function(res) gpar(fill = ifelse(res > 0, col[1], col[2]))  
}
@ 

\noindent In the call to \codefun{mosaic}, using the new
\codefun{shading3a\_fun} function, we can now simply change the colors:

<<shading4>>=
mosaic(ucb, gp = shading3a_fun(c("red","blue")))
@ 

\noindent (figure not shown).  The procedure described so far is a
rather general concept, applicable to a wide family of user-level
\pkg{grid} graphics. Indeed, the customization of other components of
the strucplot framework (labeling, spacing, legend, and core functions)
follows the same idea.  Now for the shading functions, more
customization is needed. Note that \codefun{shading3a\_fun} needs to be
evaluated by the user, even if the defaults are to be used. It is a
better idea to let \codefun{strucplot} call the generating function,
which, in particular, allows the passing of arguments that are computed
by \codefun{strucplot}. Since shading functions can be used for
visualizing significance (see Section \ref{sec:overview}), it makes
sense for generating functions to have access to the model, i.e.,
observed and expected values, residuals, and degrees of freedom. For
example, the \codefun{shading\_max} generating function computes a
permutation distribution of the maximum statistic and $p$ values for
specified significance levels based on the observed table to create
data-driven cut-off points. If this was done in the shading function
itself, the permutation statistic would be recomputed every time the
shading function is called, resulting in possibly severe performance
loss and numerical inconsistencies. Therefore, generating functions for
shadings are required to take at least the parameters \code{observed},
\code{expected}, \code{residuals}, and \code{df} (these are provided by
the strucplot framework), followed by other parameters controlling the
shading appearance (to be specified by the user):

<<shading4>>=
shading3b_fun <- function(observed = NULL, residuals = NULL, expected = NULL, 
    df = NULL, col = c("lightblue", "lightsalmon")) {
  if (length(col) != 2) stop("Need exactly two colors!")
  function(res) gpar(fill = ifelse(res > 0, col[1], col[2]))  
}
class(shading3b_fun) <- "grapcon_generator"
@ 

In some sense, generating
functions for shadings are parameterized both by the user and the
strucplot framework. For shading functions that require model
information, the user-specified parameters are 
to be passed to the \code{gp\_args} argument instead, and for this to
work, the generating function needs a class attribute to be distinguishable from
the ``normal'' shading functions. For others
(like our simple \codefun{shading3b\_fun}) this is optional, but
recommended for consistency:

<<shading5>>=
mosaic(ucb, gp = shading3b_fun, gp_args = list(col = c("red","blue")))
@

\noindent The final \codefun{shading3b\_fun} pretty much resembles 
\codefun{shading\_binary}, one of the standard shading
functions provided by the \pkg{vcd} package.

\subsection[An overview of the shading functions in vcd]{An overview of the shading functions in \pkg{vcd}}
\label{sec:overview}

\cite{vcd:Friendly:1994}
suggested a residual-based shading for the mosaic tiles that can also be applied
to the rectangles in association plots \citep{vcd:Meyer+Zeileis+Hornik:2003}.
Apart from \codefun{shading\_binary}, there are currently two basic
shadings available in \pkg{vcd}:
\codefun{shading\_hcl} and \codefun{shading\_hsv}, as well
as two derived functions: \codefun{shading\_Friendly} building upon
\codefun{shading\_hsv}, and \codefun{shading\_max} building upon \codefun{shading\_hcl}.
\codefun{shading\_hsv} and \codefun{shading\_hcl} provide
the same conceptual tools, but use different color spaces: the
Hue-Saturation-Value (HSV) and the Hue-Chroma-Luminance (HCL) scheme,
respectively. We will first expose the basic concept of these shading
functions using the HSV space, and
then briefly explain the differences to the HCL space \citep[a detailed
discussion can be found in][]{vcd:Zeileis+Meyer+Hornik:2005}. 
The HCL space is trickier
to use, but preferable to the HSV space from a perceptual point of view.

In the HSV space, colors are specified in three dimensions: Hue,
Saturation (`colorfulness'), and Value (`lightness', amount of gray). 
These three dimensions are used by \codefun{shading\_hsv} to visualize information 
about the residuals and the underlying independence model. The hue 
indicates the residuals' sign: by default, blue for positive, and red
for negative residuals. The saturation of a residual 
is set according to its size: high saturation for large, and low
saturation for small residuals. 
Finally, the overall lightness is used to indicate the significance of
a test statistic: light colors for significant, 
and dark colors for non-significant results. 

As an example, we will visualize the association of hair and eye
color in the \data{HairEyeColor} data set (see Figure \ref{fig:haireye})

<<haireye>>=
haireye <- margin.table(HairEyeColor, 1:2)
mosaic(haireye, gp = shading_hsv)
@

\begin{figure}[h]
\begin{center}
<<haireyefig,fig=TRUE,echo=FALSE,width=7,height=7>>=
<<haireye>>
@
\caption{Shaded residuals in the \data{HairEyeColor} data set---two cut-off points.}
\label{fig:haireye}
\end{center}
\end{figure}

\noindent Large positive residuals (greater than $4$) can be found for
brown eyes/black hair and blue eyes/blond hair, and are colored in saturated blue. 
On the other hand, there is a large negative residual
(less than $-4$) for brown eyes/blond hair, colored deep red. There are also three
medium-sized positive (negative) residuals between 2 and 4 ($-2$ and
$-4$): the colors for them are less saturated. Residuals between $-2$ and $2$ 
are shaded in white.
The heuristic for choosing the cut-off points $2$ and $4$ is that the Pearson residuals
are approximately standard normal which implies that the highlighted cells are those with
residuals \emph{individually} significant at approximately the $\alpha
= 0.05$ and $\alpha = 0.0001$ levels, respectively. These default cut-off points can
be changed to alternative values using the \code{interpolate}
argument (see Figure \ref{fig:interpolate}):

<<interpolate>>=
mosaic(haireye, gp = shading_hsv, gp_args = list(interpolate = 1:4))
@

\begin{figure}[h]
\begin{center}
<<interpolatefig,fig=TRUE,echo=FALSE,width=7,height=7>>=
<<interpolate>>
@
\caption{Shaded residuals in the \data{HairEyeColor} data set---four cut-off points.}
\label{fig:interpolate}
\end{center}
\end{figure}

\noindent The elements of the numeric vector passed to
\code{interpolate} define the knots of an interpolating step function
used to map the absolute residuals to saturation levels. 
The \code{interpolate} argument also accepts a user-defined function,
which then is called with the absolute residuals to get a vector of
cut-off points. Thus, it is possible to automatically choose the cut-off points 
in a data-driven way. For example,
one might think that the extension from four cut-off points 
to a continuous shading---visualizing the whole range of 
residuals---could be useful. We simply need a one-to-one
mapping from the residuals to the saturation values: 

<<continuous1>>=
ipol <- function(x) pmin(x/4, 1)
@

\noindent Note that this \codefun{ipol} 
function maps residuals greater than 4 to a saturation
level of 1. However, the resulting plot (Figure \ref{fig:continuous}) is 
deceiving: 

<<continuous2>>=
mosaic(HairEyeColor, gp = shading_hsv, gp_args = list(interpolate = ipol),
labeling_args = list(abbreviate = c(Sex = TRUE)))
@

\begin{figure}[p]
\begin{center}
<<continuousfig,fig=TRUE,echo=FALSE,height=7>>=
<<continuous2>>
@
\caption{The \data{HairEyeColor} data with continuous shading.}
\label{fig:continuous}
\end{center}
\end{figure} 

\noindent Too much color makes it difficult to interpret the image, and the subtle color
differences are hard to catch. Therefore, we only included shadings
with discrete cut-off points.

The third remaining dimension, the value, is used for
visualizing the significance of a test statistic. The user can either
directly specify the $p$ value, or, alternatively, a function that
computes it, to the \code{p.value} argument. Such a function must take
observed and expected values, residuals, and degrees of freedom (used
by the independence model) as arguments. 
If nothing is specified, the $p$ value is computed from 
a $\chi^2$ distribution with \code{df} degrees of
freedom. The \code{level} argument is used to specify the confidence
level:  if \code{p.value} is smaller than \code{1 - level}, light colors are used, 
otherwise dark colors are employed. 
The following example using the \data{Bundesliga} data 
shows the relationship of home goals and away
goals of Germany's premier soccer league in 1995: although there are two
``larger'' residuals (one greater than 2, one less then $-2$), the
$\chi^2$ test does not reject the null hypothesis of
independence. Consequently, the colors appear dark (see Figure \ref{fig:bundesliga}):

<<bundesliga>>=
bl <- xtabs(~ HomeGoals + AwayGoals, data = Bundesliga, subset = Year == 1995)
mosaic(bl, gp = shading_hsv)
@

\begin{figure}[p]
\begin{center}
<<bundesligafig,fig=TRUE,echo=FALSE,height=7>>=
<<bundesliga>>
@
\caption{Non-significant $\chi^2$ test using part of the \data{Bundesliga} data.}
\label{fig:bundesliga}
\end{center}
\end{figure}

A shading function building upon \codefun{shading\_hsv} is \codefun{shading\_Friendly},
implementing the shading introduced by \cite{vcd:Friendly:1994}. In addition
to the defaults of the HSV shading, it uses the border color and line type to 
redundantly code the residuals' sign. The following example again uses 
the \data{Bundesliga} data from above, this time using the Friendly 
scheme and, in addition, an alternative legend (see Figure \ref{fig:friendly}):

<<friendly>>=
mosaic(bl, gp = shading_Friendly, legend = legend_fixed, zero_size = 0)
@

\begin{figure}[h]
\begin{center}
<<friendlyfig,fig=TRUE,echo=FALSE,height=7>>=
<<friendly>>
@
\caption{The \data{Bundesliga} data for 1995 using the Friendly
  shading and a legend with fixed bins.}
\label{fig:friendly}
\end{center}
\end{figure}

\noindent (The \code{zero\_size = 0} argument removes the bullets indicating zero 
observed values. This feature is not provided
in the original \proglang{SAS} implementation of the Friendly mosaic plots.)

As introduced before, the default shading scheme is not
\codefun{shading\_hsv} but \codefun{shading\_hcl} due to the better
perceptual characteristics of the HCL color space.
Figure \ref{fig:shadingHSVHCL} depicts 
the HSV space in the upper panel and the HCL space in the lower panel.
On the left (right) side, we see the color scales for red (blue)
hue, respectively. The $x$-axis represents the colorfulness, and the
$y$-axis the brightness.
The boxes represent the diverging color palettes used for the shadings.
For the HSV space, we can see that the effect of changing the 
level of brightness (`value') is not the same for different levels of 
saturation, and again not the same for the two different hues.
In fact, in the HSV space all dimensions are confounded, which 
obviously is problematic for coding information. In contrast, the HCL color
space offers perceptually uniform colors: as can be seen from the lower panel, 
the chroma is homogeneous for different levels of luminance. 
Unfortunately, this comes at the 
price of the space being irregularly shaped, making it difficult to automatically select 
diverging color palettes. The following example again 
illustrates the \data{HairEyeColor} data, this time with HCL colors 
(Figure \ref{fig:hclshading1} depicts the default palette, 
and Figure \ref{fig:hclshading2} an alternative setting):

<<auxiliary_functions,echo=FALSE,results=hide>>=
hue.slice <- function(hue, grid.n = 101, type = c("HCL", "HSV"), plot = TRUE, fixup = FALSE)
{
  type <- match.arg(type)
  if(type == "HCL") {
    chroma = seq(0, 100, length = grid.n)
    luminance = seq(0, 100, length = grid.n)
    nc <- length(chroma)
    nl <- length(luminance)
    color.slice <- outer(chroma, luminance, function(y, x) hcl(hue, x, y, fixup = fixup))
    xlab <- "chroma"
    ylab <- "luminance"
    main <- paste("hue =", round(hue, digits = 0))
  } else {
    chroma = seq(0, 1, length = grid.n)
    luminance = seq(0, 1, length = grid.n)
    nc <- length(chroma)
    nl <- length(luminance)
    color.slice <- outer(chroma, luminance, function(y, x) hsv(hue, x, y))
    xlab <- "saturation"
    ylab <- "value"
    main <- paste("hue =", round(hue, digits = 3))
  }
  if(plot) {
    plot(0.5, 0.5, xlim = range(chroma), ylim = range(luminance), type = "n", axes = FALSE,
         xlab = xlab, ylab = ylab, yaxs = "i", xaxs = "i", main = main)
    for(i in 1:(nc-1)) {
      rect(chroma[i], luminance[-nl], chroma[i] + 100/(nc-1), luminance[-1], border = color.slice[,i+1], col = color.slice[,i+1])
    }
    axis(1)
    axis(2)
    box()
  }
  colnames(color.slice) <- chroma
  rownames(color.slice) <- luminance
  attr(color.slice, "type") <- type
  class(color.slice) <- "slice"
  invisible(color.slice)
}
@

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<shading_HSV,fig=TRUE,echo=FALSE,height=7,width=8>>=
## generate colors
hue23 <- hue.slice(2/3, grid.n = 101, plot = FALSE, type = "HSV")
hue0 <- hue.slice(0, grid.n = 101, plot = FALSE, type = "HSV")
saturation <- as.numeric(colnames(hue23))
value <- as.numeric(rownames(hue23))

## select those with value >= 0.5
hue23 <- hue23[value >= .5, ]
hue0 <- hue0[value >= .5, ]
value <- value[value >= .5]
nl <- nrow(hue23)
nc <- ncol(hue23)

## plot 2 slides from HSV space
plot(0.5, 0.5, xlim = c(-1, 1), ylim = c(0, 1), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
for(i in 1:(nc-1)) {
  rect(saturation[i], value[-nl], saturation[i] + 1/(nc-1), value[-1], border = hue23[,i+1], col = hue23[,i+1])
}
for(i in 1:(nc-1)) {
  rect(-saturation[i], value[-nl], -(saturation[i] + 1/(nc-1)), value[-1], border = hue0[,i+1], col = hue0[,i+1])
}
axis(2, at = c(50, 75, 100)/100, labels = c(0.5, 0.75, 1))
axis(4, at = c(50, 75, 100)/100, labels = c(0.5, 0.75, 1))
axis(3, at = -4:4*.25, labels=c(4:0*.25, 1:4*.25))
mtext(c("hue = 0", "hue = 2/3"), side = 3, at = c(-.5, .5), line = 3, cex = 1.2)
mtext("saturation", side = 3, at = 0, line = 2)
mtext("value", side = 2, at = .75, line = 2)
mtext("value", side = 4, at = .75, line = 2)
lines(c(-1, 1), c(.5, .5))

## significant colors
rect(-1, 0.95, -.90, 1, col = hsv(0, 1, 1))
rect(-0.45, 0.95, -.55, 1, col = hsv(0, 0.5, 1))
rect(-.05, .95, .05, 1, col = hsv(2/3, 0, 1))
rect(0.45, 0.95, .55, 1, col = hsv(2/3, 0.5, 1))
rect(.90, .95, 1, 1, col = hsv(2/3, 1, 1))

text(-1, .33, "significant", pos = 4, cex = 1.2)
rect(-1, .20, -.80, .30, col = hsv(0, 1, 1))
rect(-.40, .20, -0.6, .30, col = hsv(0, 0.5, 1))
rect(-.20, .20, 0, .30, col = hsv(0, 0, 1))
rect(0, .20, .20, .30, col = hsv(2/3, 0, 1))
rect(0.4, .20, .60, .30, col = hsv(2/3, .5, 1))
rect(.80, .20, 1, .30, col = hsv(2/3, 1, 1))

lines(c(-.9, -.55), c(0.975, .975), lty = 2)
lines(c(-.45, -.05), c(0.975, .975), lty = 2)
lines(c(.45, .05), c(0.975, .975), lty = 2)
lines(c(.9, .55), c(0.975, .975), lty = 2)

## non-significant colors
rect(-1, 0.5, -.90, 0.55, col = hsv(0, 1, 0.5))
rect(-0.45, 0.5, -.55, 0.55, col = hsv(0, 0.5, 0.5))
rect(-.05, .5, .05, 0.55, col = hsv(2/3, 0, 0.5))
rect(0.45, 0.5, .55, 0.55, col = hsv(2/3, 0.5, 0.5))
rect(.90, .5, 1, 0.55, col = hsv(2/3, 1, 0.5))

text(-1, .13, "non-significant", pos = 4, cex = 1.2)
rect(-1, 0, -.80, .10, col = hsv(0, 1, 0.5))
rect(-.60, 0, -.4, .10, col = hsv(0, 0.5, 0.5))
rect(-.20, 0, 0, .10, col = hsv(0, 0, 0.5))
rect(0, 0, .20, .10, col = hsv(2/3, 0, 0.5))
rect(0.4, 0, .60, .1, col = hsv(2/3, .5, 0.5))
rect(.80, 0, 1, .10, col = hsv(2/3, 1, 0.5))

lines(c(-.9, -.55), c(0.525, .525), lty = 2)
lines(c(-.45, -.05), c(0.525, .525), lty = 2)
lines(c(.45, .05), c(0.525, .525), lty = 2)
lines(c(.9, .55), c(0.525, .525), lty = 2)
@ 

<<shading_HCL,fig=TRUE,echo=FALSE,height=7,width=8>>=
## generate colors
hue260 <- hue.slice(260, grid.n = 101, plot = FALSE)
hue360 <- hue.slice(360, grid.n = 101, plot = FALSE)
mychroma <- as.numeric(colnames(hue260))
luminance <- as.numeric(rownames(hue260))

## select those with lumincance >= 50
hue260 <- hue260[luminance >= 50, ]
hue360 <- hue360[luminance >= 50, ]
luminance <- luminance[luminance >= 50]
nc <- ncol(hue260)
nl <- nrow(hue260)

## plot 2 slides from HCL space
plot(0.5, 0.5, xlim = c(-100, 100), ylim = c(0, 100), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
for(i in 1:(nc-1)) {
  rect(mychroma[i], luminance[-nl], mychroma[i] + 100/(nc-1), luminance[-1], border = hue260[,i+1], col = hue260[,i+1])
}
for(i in 1:(nc-1)) {
  rect(-mychroma[i], luminance[-nl], -(mychroma[i] + 100/(nc-1)), luminance[-1], border = hue360[,i+1], col = hue360[,i+1])
}
axis(2, at = c(50, 70, 90, 100), labels = c(50, 70, 90, 100))
axis(4, at = c(50, 70, 90, 100), labels = c(50, 70, 90, 100))
axis(3, at = -4:4*25, labels=c(4:0*25, 1:4*25))
mtext(c("hue = 0", "hue = 260"), side = 3, at = c(-50, 50), line = 3, cex = 1.2)
mtext("chroma", side = 3, at = 0, line = 2)
mtext("luminance", side = 2, at = 75, line = 2)
mtext("luminance", side = 4, at = 75, line = 2)
lines(c(-100, 100), c(50, 50))

## significant colors
rect(-100, 47.5, -90, 52.5, col = hcl(0, 100, 50))
rect(-55, 67.5, -45, 72.5, col = hcl(0, 50, 70))
rect(-5, 95, 5, 100, col = hcl(260, 0, 100))       ## grey vs. white
rect(-5, 87.5, 5, 92.5, col = hcl(260, 0, 90))     ## grey vs. white
rect(45, 67.5, 55, 72.5, col = hcl(260, 50, 70))
rect(90, 47.5, 100, 52.5, col = hcl(260, 100, 50))

text(-100, 33, "significant", pos = 4, cex = 1.2)
rect(-100, 20, -80, 30, col = hcl(0, 100, 50))
rect(-60, 20, -40, 30, col = hcl(0, 50, 70))
rect(-20, 20, 0, 30, col = hcl(0, 0, 90))       
rect(0, 20, 20, 30, col = hcl(260, 0, 90))
#white# rect(-20, 20, 0, 30, col = hcl(0, 0, 100))
#white# rect(0, 20, 20, 30, col = hcl(260, 0, 100))
rect(40, 20, 60, 30, col = hcl(260, 50, 70))
rect(80, 20, 100, 30, col = hcl(260, 100, 50))

lines(c(-45, -5), c(72.5, 87.5), lty = 2)
lines(c(45, 5), c(72.5, 87.5), lty = 2)
lines(c(-95, -55), c(52.5, 67.5), lty = 2)
lines(c(95, 55), c(52.5, 67.5), lty = 2)

## non-significant colors
rect(-25, 47.5, -15, 52.5, col = hcl(0, 20, 50))
rect(-15, 67.5, -5, 72.5, col = hcl(0, 10, 70))
rect(5, 67.5, 15, 72.5, col = hcl(260, 10, 70))
rect(25, 47.5, 15, 52.5, col = hcl(260, 20, 50))


text(-100, 13, "non-significant", pos = 4, cex = 1.2)
rect(-60, 0, -40, 10, col = hcl(0, 20, 50))
rect(-40, 0, -20, 10, col = hcl(0, 10, 70))
rect(-20, 0, 0, 10, col = hcl(0, 0, 90))
rect(0, 0, 20, 10, col = hcl(260, 0, 90))
rect(20, 0, 40, 10, col = hcl(260, 10, 70))
rect(40, 0, 60, 10, col = hcl(260, 20, 50))

lines(c(-18.75, -11.25), c(52.5, 67.5), lty = 2)
lines(c(-8.75, -1.25), c(72.5, 87.5), lty = 2)
lines(c(18.75, 11.75), c(52.5, 67.5), lty = 2)
lines(c(8.75, 1.25), c(72.5, 87.5), lty = 2)
@ 
\caption{Residual-based shadings in HSV (upper) and HCL space (lower).}
\label{fig:shadingHSVHCL}
\end{center}
\end{figure}


<<hclshading1>>=
mosaic(haireye, gp = shading_hcl)
@ 
<<hclshading2>>=
mosaic(haireye, gp = shading_hcl, gp_args = list(h = c(130, 43), c = 100, l = c(90, 70)))
@ 

\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}[p]
\begin{center}
<<hclshading1fig,fig=TRUE,echo=FALSE,height=6>>=
<<hclshading1>>
@
\caption{The \data{HairEyeColor} data, using default HCL color palette.}
\label{fig:hclshading1}
\end{center}
\end{figure}

\begin{figure}[p]
\begin{center}
<<hclshading2fig,fig=TRUE,echo=FALSE,height=6>>=
<<hclshading2>>
@
\caption{The \data{HairEyeColor} data, using a custom HCL color palette.}
\label{fig:hclshading2}
\end{center}
\end{figure}

A more `advanced' function building upon \codefun{shading\_hcl} 
is \codefun{shading\_max}, using the
maximum statistic both to conduct the independence test and to 
visualize significant \emph{cells} causing the
rejection of the independence hypothesis \citep{vcd:Meyer+Zeileis+Hornik:2003}. The
\code{level} argument of \codefun{shading\_max} 
then can be used to specify several confidence
levels from which the corresponding cut-off points are computed. 
By default, two cut-off points are computed corresponding 
to confidence levels of $90\%$ and $99\%$, respectively.
In the following example, we investigate the effect of a new treatment
for rheumatoid arthritis on a group of female patients using the
maximum shading (see Figure \ref{fig:maximum}):

<<arthritis>>=
mosaic(~ Treatment + Improved, data = Arthritis, subset = Sex == "Female",
       gp = shading_max)
@

\begin{figure}[h]
\begin{center}
<<arthritisfig,fig=TRUE,echo=FALSE>>=
<<arthritis>>
@
\caption{Significant maximum test on female patients of the \data{Arthritis}
  data.}
\label{fig:maximum}
\end{center}
\end{figure}

\noindent The maximum test is significant although the residuals are
all in the $\left[-2,2\right]$ interval.
The \codefun{shading\_hcl} function with default cut-off points would
not have shown any color. In addition, since the test statistic is the
maximum of the absolute Pearson residuals, \emph{each} colored
residual violates the null hypotheses of independence, and thus, the
`culprits' can immediately be identified.

\section[Flexible labeling]{Flexible labeling}
\label{sec:labeling}

One of the major enhancements in package \pkg{vcd} compared to
\codefun{mosaicplot} and \codefun{assocplot} in
base \proglang{R} is the labeling in the strucplot framework which 
offers many more features and flexibility. 
Like shading, spacing, and drawing of legend and core plot, 
labeling is now carried out by grapcon functions, rendering labeling completely
modular.
The user supplies either a labeling function, or, alternatively, 
a generating function that parameterizes a labeling function, 
to \codefun{strucplot} which then draws the labels.
Labeling is well-separated from the actual plotting that occurs in the
low-level core functions. It only relies on the viewport tree produced by them, and the
`\texttt{dimnames}' attribute of the visualized table. Labeling
functions are grapcons that ``add ink to the canvas'': the drawing of the
labels happens after the actual plot has been drawn by the core function.
Thus, it is possible to supply one's own labeling function, or
to combine some of the basic functions to produce a more complex labeling.
In the following, we describe the three basic modules
(\codefun{labeling\_text}, \codefun{labeling\_list}, and \codefun{labeling\_cells}) and
derived functions that build upon them.

\subsection[Labels in the borders]{Labels in the borders: \texttt{labeling\_text()}}

\codefun{labeling\_text} is the default for all strucplot displays. It
plots labels in the borders similar to the \codefun{mosaicplot}
function in base \proglang{R}, but is much more flexible: it is not limited
to 4 dimensions, and the positioning and graphical parameters 
of levels and variable names are customizable. In addition,
the problem of overlapping labels can be handled in several ways. 

As an example, consider the \data{Titanic} data, consisting
of 4 categorical variables: survival (`survived'), gender (i.e., `sex'), age, and
crew. By default, the variable names and levels are plotted `around' the
plot in a counter-clockwise way (see Figure \ref{fig:defaults}):

<<default>>=
mosaic(Titanic)
@

\begin{figure}[p]
\begin{center}
<<defaultfig,fig=TRUE,echo=FALSE>>=
<<default>>
@
\caption{Mosaic plot for the \data{Titanic} data with default settings
  for labeling.}
\label{fig:defaults}
\end{center}
\end{figure}

\noindent Note that the last two levels of the `survived' variable do
overlap, as well as some adult and child labels of the `age' Variable.
This issue can be addressed in several ways. The `brute force'
method is to enable clipping for these dimensions (see Figure \ref{fig:clipping}):

<<clipping>>=
mosaic(Titanic, labeling_args = list(clip = c(Survived = TRUE, Age = TRUE)))
@

\begin{figure}[p]
\begin{center}
<<clippingfig,fig=TRUE,echo=FALSE>>=
<<clipping>>
@
\caption{The effect of clipping.}
\label{fig:clipping}
\end{center}
\end{figure}

\noindent The \code{clip} parameter is passed to the labeling function
via the \code{labeling\_args} argument which takes a list of
parameters. \code{clip} itself takes a vector of logicals (one for
each dimension). 
% as mentioned before
Almost all vectorized arguments in the strucplot
framework can be abbreviated in the following way: unnamed components
(or the defaults, if there are none) are recycled as needed, but
overridden by the named components. Here, the default is \code{FALSE},
and therefore clipping is enabled only for the `survived' and `age' variables.
A more sensible solution to the overlap problem is to abbreviate the 
levels (see Figure \ref{fig:abbreviating}):

<<abbreviating>>=
mosaic(Titanic, labeling_args = list(abbreviate = c(Survived = TRUE, Age = 3)))
@

\begin{figure}[h]
\begin{center}
<<abbreviatingfig,fig=TRUE,echo=FALSE>>=
<<abbreviating>>
@
\caption{Abbreviating.}
\label{fig:abbreviating}
\end{center}
\end{figure}

\noindent The \code{abbreviate} argument takes a vector of
integers indicating the number of significant characters the levels should be
abbreviated to (\code{TRUE} is interpreted as 1, obviously). Abbreviation
is performed using the \codefun{abbreviate} function in base \proglang{R}. Another
possibility is to rotate the levels (see Figure~\ref{fig:rotating}):

<<rotate>>=
mosaic(Titanic, labeling_args = list(rot_labels = c(bottom = 90, right = 0), 
offset_varnames = c(right = 1), offset_labels = c(right = 0.3)), margins = c(right = 4, bottom = 3))
@

\begin{figure}[p]
\begin{center}
<<rotatefig,fig=TRUE,echo=FALSE,height=6>>=
<<rotate>>
@
\caption{Rotating labels.}
\label{fig:rotating}
\end{center}
\end{figure}

\noindent Finally, we could also inhibit the output of repeated levels 
(see Figure \ref{fig:repeat}):

<<repeat>>=
mosaic(Titanic, labeling_args = list(rep = c(Survived = FALSE, Age = FALSE)))
@

\begin{figure}[p]
\begin{center}
<<repeatfig,fig=TRUE,echo=FALSE,height=6>>=
<<repeat>>
@
\caption{Inhibiting the repetition of levels.}
\label{fig:repeat}
\end{center}
\end{figure}

We now proceed with a few more `cosmetic' features (which do not all
produce satisfactory results for our sample data).
A first simple, but effectful modification is to position
all labels and variables left-aligned:  (see Figure \ref{fig:left}):

<<left>>=
mosaic(Titanic, labeling_args = list(pos_varnames = "left", pos_labels = "left", 
       just_labels = "left", rep = FALSE))
@

\begin{figure}[h]
\begin{center}
<<leftfig,fig=TRUE,echo=FALSE>>=
<<left>>
@
\caption{Left-aligning.}
\label{fig:left}
\end{center}
\end{figure}

\noindent Note that obviously we need to change the justification 
to \code{"left"} as well. We can
achieve the same effect by using the convenience function \codefun{labeling\_left}: 

<<left2>>=
mosaic(Titanic, labeling = labeling_left)
@

\noindent Next, we show how to put all levels to the
bottom and right margins, and all variable names to the top and left
margins (see Figure \ref{fig:margins}):

<<margins>>=
mosaic(Titanic, labeling_args = list(tl_labels = FALSE, tl_varnames = TRUE, abbreviate = c(Survived = 1, Age = 3)))
@

\begin{figure}[p]
\begin{center}
<<marginsfig,fig=TRUE,echo=FALSE,height=6>>=
<<margins>>
@
\caption{Changes in the margins.}
\label{fig:margins}
\end{center}
\end{figure}

\noindent The \var{tl\_foo} (``top left'') arguments are \code{TRUE} by default. 
Now, we will add boxes to the labels and additionally
enable clipping (see Figure \ref{fig:boxes}):

<<boxes>>=
mosaic(Titanic, labeling_args = list(tl_labels = FALSE, tl_varnames = TRUE, 
       boxes = TRUE, clip = TRUE))
@

\begin{figure}[p]
\begin{center}
<<boxesfig,fig=TRUE,echo=FALSE,height=6>>=
<<boxes>>
@
\caption{Boxes and Clipping.}
\label{fig:boxes}
\end{center}
\end{figure}

\noindent The values to \code{boxes} and \code{clip} are recycled for
all dimensions. The result is pretty close to what calling
\codefun{mosaic} with the \codefun{labeling\_cboxed}
wrapper does, except that variables and levels, by default, are put to the top and
to the left of the plot:

<<boxes2>>=
mosaic(Titanic, labeling = labeling_cboxed)
@ 

\noindent Another variant is to put the variable names into the
same line as the levels (see Figure \ref{fig:labbl}):

<<labbl>>=
mosaic(Titanic, labeling_args = list(tl_labels = TRUE, boxes = TRUE,
       clip = c(Survived = FALSE, TRUE), 
       labbl_varnames = TRUE), margins = c(left = 4, right = 1, 3))
@

\begin{figure}[h]
\begin{center}
<<labblfig,fig=TRUE,echo=FALSE>>=
<<labbl>>
@
\caption{Variable names beneath levels.}
\label{fig:labbl}
\end{center}
\end{figure}

\noindent \code{labbl\_varnames} (``variable names to the bottom/left of the
labels'') is a vector of logicals indicating the side for the
variable names. The resulting layout is close to what
\codefun{labeling\_lboxed} produces, except that variables and levels,
by default, are left-aligned and put to the bottom and to the right of the plot:

<<labbl2>>=
mosaic(Titanic, labeling = labeling_lboxed, margins = c(right = 4, left = 1, 3))
@ 

\noindent A similar design is used by the \codefun{doubledecker} function.

\subsection[Labels in the cells]{Labels in the cells: \texttt{labeling\_cells()}}

This labeling draws both variable names and levels in the
cells. As an example, we use the \data{PreSex} data on pre- and
extramarital sex and divorce (see Figure \ref{fig:cell}):

<<cell>>=
mosaic(~ MaritalStatus + Gender, data = PreSex, labeling = labeling_cells)
@

\begin{figure}[h]
\begin{center}
<<cellfig,fig=TRUE,echo=FALSE,width=7,height=7>>=
<<cell>>
@
\caption{Cell labeling for the \data{PreSex} data.}
\label{fig:cell}
\end{center}
\end{figure}

\noindent In the case of narrow cells, it might be useful to
abbreviate labels and/or variable names and turn off clipping (see Figure \ref{fig:cell2}):

<<cell2>>=
mosaic(~ PremaritalSex + ExtramaritalSex, data = PreSex, 
labeling = labeling_cells(abbreviate_labels = TRUE, abbreviate_varnames = TRUE, clip = FALSE))
@

\begin{figure}[h]
\begin{center}
<<cell2fig,fig=TRUE,echo=FALSE>>=
<<cell2>>
@
\caption{Cell labeling for the \data{PreSex} data, labels abbreviated.}
\label{fig:cell2}
\end{center}
\end{figure}

\noindent For some data, it might be convenient to combine cell
labeling with border labeling as done by \codefun{labels\_conditional}
(see Figure \ref{fig:conditional}):

<<conditional>>=
mosaic(~ PremaritalSex + ExtramaritalSex | MaritalStatus + Gender, data = PreSex, labeling = labeling_conditional(abbreviate_varnames = TRUE, abbreviate_labels = TRUE, clip = FALSE))
@

\begin{figure}[h]
\begin{center}
<<conditionalfig,fig=TRUE,echo=FALSE>>=
<<conditional>>
@
\caption{Conditional labeling for the \data{PreSex}, labels abbreviated.}
\label{fig:conditional}
\end{center}
\end{figure}

\noindent Additionally, the cell labeling allows the user to add
arbitrary text to the cells by supplying a character array in the same
shape than the data array to the \code{text} argument (cells with missing values
are ignored). In the following example using the `Titanic' data, 
this is used to add all observed values greater
than 5 to the cells after the mosaic has been plotted (see Figure \ref{fig:text}):

<<text>>=
mosaic(Titanic, labeling_args = list(abbreviate = c(Survived = 1, Age = 4)), pop = FALSE)

tab <- ifelse(Titanic < 6, NA, Titanic)
labeling_cells(text = tab, clip = FALSE)(Titanic)
@

\begin{figure}[h]
\begin{center}
<<textfig,fig=TRUE,echo=FALSE>>=
<<text>>
@
\caption{User-supplied Text added to a mosaic display of the \data{Titanic} data.}
\label{fig:text}
\end{center}
\end{figure}

\subsection[A simple list of labels]{A simple list of labels: \texttt{labeling\_list()}}

If problems with overlapping labels cannot satisfactorily resolved,
the last remedy could be to simply list the levels below the plot
(see Figure \ref{fig:list}):

<<list>>=
mosaic(Titanic, labeling = labeling_list, margins = c(bottom = 5))
@

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[h]
\begin{center}
<<listfig,fig=TRUE,echo=FALSE>>=
<<list>>
@
\caption{Labels indicated below the plot.}
\label{fig:list}
\end{center}
\end{figure}

\noindent The number of columns can be specified.

\section{Customizable spacing}
\label{sec:spacing}

Spacing of strucplot displays is customizable in a similar way than shading. The
\code{spacing} argument of the \codefun{strucplot} function takes a
list of \class{unit} vectors, one for each dimension, specifying the
space between the tiles corresponding to the levels. As an example,
consider the introductory example of the \data{Arthritis} data 
(Figure \ref{fig:arthritis}). Since we are interested in the effect of
the medicament in the placebo and treatment groups, a mosaic plot is
certainly appropriate to visualize the three levels of `Improved' in
the two `Treatment' strata. Another conceptual approach is to use
spine plots with highlighting \citep{vcd:hummel:1996}. A spine plot is
a variation of a bar plot where the heights of the bars are held
constant, whereas the widths are used to represent the number of cases
in each category. This is equivalent to a mosaic plot for a one-way table.
If a second (indicator) variable is highlighted in a spine plot, we
obtain a display equivalent to a simple mosaic display for a two-way
table, except that no space between the levels of the highlighted
variable is used.
In the \data{Arthritis} example, we will highlight patients with `Marked' 
improvement in both groups. To obtain such a display within 
the strucplot framework\footnote{The \pkg{vcd} package also provides 
a specialized \codefun{spine} function for spine plots and spinograms.}, it
suffices to set the space between the `Improved' tiles to 0 (see
Figure \ref{fig:artspine}):

<<artspine,echo=TRUE,results=verbatim>>=
(art <- structable(~Treatment + Improved, data = Arthritis, split_vertical = TRUE))
(my_spacing <- list(unit(0.5, "lines"), unit(c(0, 0), "lines")))
my_colors <- gpar(fill = c("lightgray", "lightgray", "black"))
mosaic(art, spacing = my_spacing, gp = my_colors)
@ 

\begin{figure}[p]
\begin{center}
<<artspinefig,echo=FALSE,fig=TRUE>>=
<<artspine>>
@ 
\caption{Spine plot for the \data{Arthritis} data using the strucplot framework.}
\label{fig:artspine}
\end{center}
\end{figure}

\noindent The strucplot framework also provides a set of spacing grapcon
generators that compute suitable spacing objects for
typical applications. The simplest spacing is \codefun{spacing\_equal}
that uses the same space between all tiles:

<<space1>>=
mosaic(art, spacing = spacing_equal(unit(2, "lines")))
@ 

\noindent \codefun{spacing\_equal} is the default grapcon generator for
two-dimensional tables. Slightly more flexible is \codefun{spacing\_dimequal} that
allows an individual setting for each dimension:

<<space2>>=
mosaic(art, spacing = spacing_dimequal(unit(1:2, "lines")))
@ 

\noindent The default for multi-way contingency tables is
\codefun{spacing\_increase} that uses increasing spaces for the dimensions. The user can specify a start value and the increase factor:

<<space3>>=
mosaic(art, spacing = spacing_increase(start = unit(0.5, "lines"), rate = 1.5))
@ 

\noindent For the arthritis example above, we could as well have used
\codefun{spacing\_highlighting} that is similar to \codefun{spacing\_increase} but
sets the spacing in the last splitting dimension to 0:

<<spine4>>=
mosaic(art, spacing = spacing_highlighting, gp = my_colors)
@ 

\noindent Finally, \codefun{spacing\_conditional} can be used for
visualizing conditional independence: it combines
\codefun{spacing\_equal} (for the conditioned dimensions) and 
\codefun{spacing\_increase} (for the conditioning dimensions). As an example, 
consider Figure \ref{fig:presex}: the spacing clearly allows to better 
distinguish the conditioning variables 
(`Gender' and `MaritalStatus') from the conditioned 
variables (`PremaritalSex' and `ExtramaritalSex'). This
spacing is the default when conditional variables are specified for a
strucplot display (see Section \ref{sec:strucplot}).

\section{Conclusion}
\label{sec:conclusion}

In this paper, we describe the `strucplot' framework for the visualization of
multi-way contingency tables. Strucplot displays include popular 
basic plots such as mosaic, association, and sieve plots, integrated 
in a unified framework: all can be seen as graphical visualizations of
hierarchical conditional flat tables. 
Additionally, these core strucplot displays can be combined into more complex, 
specialized plots, such as pairs and trellis-like displays for visualizing
conditional independence. Residual-based shadings permit the
visualization of log-linear models and the results of independence tests.
The frameworks' modular design allows
flexible customization of the plots' graphical appearance, including 
shading, labeling, spacing, and legend, by means of graphical
appearance control (`grapcon') functions. These `graphical
hyperparameters' are customized and created by
generating functions. Our work includes a set of predefined grapcon generators for
typical analysis tasks, and user-level extensions can easily be added.

\bibliography{vcd}

\begin{appendix}

\section{Data sets}
\label{sex:data}

The data set names in the paper are those from the \proglang{R}
system. In the following, we give a short description of each data set.

\begin{description}
\item[\texttt{Arthritis}] Data from \cite{vcd:Koch+Edwards:1988} from a 
  double-blind clinical trial
  investigating a new treatment for rheumatoid arthritis. Package:
  \pkg{vcd}.
\item[\texttt{Bundesliga}] Results from the first German soccer league in the
  years 1995/6 \citep{vcd:Knorr-Held:1999} and 2001/2 (Achim
  Zeileis). Package: \pkg{vcd}.
\item[\texttt{HairEyeColor}] Distribution of hair and eye color and 
  gender in 592 statistics
  students. The gender information is artificial. Source: \cite{vcd:Snee:1974}.
  Package: \pkg{datasets} (included in base \proglang{R}).
\item[\texttt{PreSex}]  Data from \cite{vcd:thornes+collard:1979} reported in 
  \cite{vcd:gilbert:1981}, on pre- and extra-marital sex and divorce. Package:
  \pkg{vcd}.
\item[\texttt{Titanic}] Information on the fate of passengers on
  the fatal maiden voyage of the ocean liner `Titanic', summarized
  according to economic status (class), gender (`Sex'), age and
  survival.  Source: \cite{vcd:dawson:1995} (Data 
  originally collected by the British Board of Trade
  in their investigation of the sinking). 
  Package: \pkg{datasets} (included in base \proglang{R}).
\item[\texttt{UCBAdmissions}] 
  Aggregate data on applicants to graduate school at Berkeley for
  the six largest departments in 1973 classified by admission and
  gender. Source: \cite{vcd:Bickel+Hammel+O'Connell:1975}. 
  Package: \pkg{datasets} (included in base \proglang{R}).
\end{description}

\section{Code used in the introduction}
\label{sec:code}

\begin{itemize}

\item Mosaic plot for the \data{Arthiritis} data in Figure \ref{fig:arthritis}:
\begin{Sinput}
mosaic(art, gp = shading_max, split_vertical = TRUE)
\end{Sinput}

\item Conditional association plot for the \data{UCBAdmissions} 
data in Figure \ref{fig:ucbadmissions}:
\begin{Sinput}
cotabplot(UCBAdmissions, panel = cotab_assoc, shade = TRUE, legend = FALSE)
\end{Sinput}

\item Mosaic plot for the \data{PreSex} data in Figure \ref{fig:presex}:
\begin{Sinput}
mosaic(PreSex, condvars = c(1, 4), shade = TRUE)
\end{Sinput}

\item Double-decker plot for the \data{Titanic} data in Figure \ref{fig:titanic}:
\begin{Sinput}
doubledecker(Survived ~ ., data = Titanic, labeling_args = 
             list(set_varnames = c(Sex = "Gender")))
\end{Sinput}
\end{itemize}

\end{appendix}

\end{document}
