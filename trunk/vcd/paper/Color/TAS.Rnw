\documentclass{Z}
%% need no \usepackage{Sweave}
\SweaveOpts{engine=R, eps=FALSE, echo=FALSE, results=hide}
\usepackage{amsfonts}

\title{Choosing Color Palettes for Statistical Graphics}
\author{Achim Zeileis \textnormal{and} Kurt Hornik\\Wirtschaftsuniversit\"at Wien, Austria}
\Plainauthor{Achim Zeileis, Kurt Hornik}
\Keywords{qualitative palette, sequential palette, diverging palette, HCL colors, HSV colors, perceptually-based color space}

\Abstract{
  Statistical graphics are often augmented by the use of color
  coding information contained in some variable. When this involves
  the shading of areas (and not only points or lines)---e.g., as in bar plots, pie charts,
  mosaic displays or heatmaps---it is important that the colors are perceptually based
  and do not introduce optical illusions or systematic bias. Here, we discuss
  how the perceptually-based Hue-Chroma-Luminance (HCL) color space can be used for deriving suitable
  color palettes for coding categorical data (qualitative palettes) and numerical
  variables (sequential and diverging palettes).
}

\begin{document}

<<preliminaries>>=
library("vcd")
library("mvtnorm")
library("KernSmooth")

source("functions.R")
source("Nigeria/bnd.R")

generate_png <- TRUE
@

\section{Introduction} \label{sec:intro}

Color is an integral element of graphical displays in general, and many statistical
graphics in particular. Statistical software packages typically provide various color
palettes and allow practitioners to employ these for visualizing data in various types
of displays. However, more often than not, there is relatively little guidance about
how to choose a suitable palette for a certain visualization task. Consequently,
sub-optimal color palettes are used for too many color graphics displayed in journal articles
or on presentation slides which could easily be enhanced if the underlying information
were captured appropriately in the color schemes. Here, we address
this problem by suggesting a color selection strategy for visualizing both categorical
and numerical information by selecting colors along axes in a color space whose axes
can be matched with perceptual axes of the human visual system.

For implementing color palettes in computer programs, typically color spaces are
employed that provide a mapping to Red-Green-Blue (RGB) colors. RGB is an additive
color model which is used for generating colors on computer screens
\citep[by mixing different amounts of the primary colors red, green and blue,
see][for more details]{vcd:Poynton:2000}. While being eminently useful for generating
colors on computer screens, it is hard for humans to select the coordinates in RGB
space corresponding to a certain color. Therefore, color picker tools in computer
programs are based on different color models---starting from the pioneering introduction
of Hue-Saturation-Value (HSV) colors \citep{vcd:Smith:1978}---which try to capture the
dimensions of human visual perception. HSV space is a simple transformation of RGB
space which is also implemented in many statistical software packages
\citep[see][for more details on HSV colors and links to further information about the other color
spaces discussed in the following]{vcd:Wiki+HSV:2006}. Although being easy to use,
HSV space exhibits a number of disadvantages: It is relatively difficult to select sets of
HSV coordinates that yield colors that are ``in harmony'' \citep[see][]{vcd:Munsell:1905}.
The reason for this is that colors with different hues also differ in saturation and brightness.
For statistical graphics, this is important because it can introduce size distortions in
the perception of shaded areas and color-caused optical illusions \citep{vcd:Cleveland+McGill:1983}.
Furthermore, the use of HSV colors encourages the use of flashy and highly saturated
colors which are good for drawing attention to a plot but hard to look at for a longer time.

Despite these known drawbacks, HSV space is still the predominantly-used color model in
color picker tools \citep{vcd:Moretti+Lyons:2002,vcd:Meier+Spalter+Karelitz:2004}
and the basis for many palettes in statistical software packages. A notable
exception is \pkg{ColorBrewer.org} \citep{vcd:Harrower+Brewer:2003},
an online tool for selecting color schemes for maps. It provides a rich
collection of prefabricated palettes (with a fixed maximal number
of colors) and guides its users how to choose a suitable palette for coding
various types of information. Here, we take a similar approach
and describe strategies for the choice of color palettes for categorical and numerical
data. Following \cite{vcd:Brewer:1999} and \cite{vcd:Harrower+Brewer:2003}, we distinguish
three types of palettes: qualitative, sequential and diverging. The first is tailored
for coding categorical information and the latter two are aimed at numerical variables
(or ordinal variables if some numerical coding for its levels is used).
Unlike \pkg{ColorBrewer.org}, we do not only provide fixed sets of colors but suggest
a general principle for selecting colors by traversing paths along perceptual axes in
a suitable color space. Consequently, the user can decide which path exactly should be
taken and how many colors should be selected. The color space employed by us is the
Hue-Chroma-Luminance (HCL) color space \citep[see][]{vcd:Ihaka:2003} and we show how
the general principles suggested can be turned into formulas describing paths of
coordinates in this space. Given a mapping from HCL to RGB coordinates, our formulas are
extremely easy to implement in software and we provide such an implementation
in the \proglang{R} language \citep{vcd:R:2006} using the powerful \proglang{R} graphics
system \citep[see][]{vcd:Murrell:2006} and the HCL
color implementation from package \pkg{colorspace} \citep{vcd:Ihaka:2006}. This gives the user
both a conceptual and computational tool box for experimenting with color palettes for
a particular display.

The remainder of the paper is organized as follows: Section~\ref{sec:motivation} provides
several motivating examples, showing how typical HSV-based graphics can be enhanced
by using HCL-based palettes. Section~\ref{sec:spaces} gives a brief introduction
to the underlying HSV and HCL color spaces before Section~\ref{sec:palettes} 
suggests strategies for deriving HCL-based qualitative, sequential, and diverging palettes.
Section~\ref{sec:software} offers some general remarks on the implementation in statistical
software packages as well as some details on our implementation in \proglang{R}.
Section~\ref{sec:discussion} concludes the paper with a discussion.


\section{Motivation} \label{sec:motivation}

To show what can be gained by selecting appropriate color schemes, we present a collection
of illustrations with typical color graphics based on HSV palettes (always in the left panels)
and more suitable HCL palettes (always in the right panels). All HSV color palettes (and some
of the data sets) are taken from recent publications in statistical journals such as
\textit{Journal of the American Statistical Association},
\textit{Journal of Computational and Graphical Statistics} or
\textit{Computational Statistics \& Data Analysis}. The examples have been selected to provide
an overview of (typically colored) statistical graphics and their respective pitfalls (when
it comes to color palette choice). All graphics are in principle very useful but can be even enhanced
by using better color schemes.

Our first illustration is a heatmap, a very popular display for visualizing a function of
two arguments. Here, we use a bivariate kernel density estimate \citep[for the Old
Faithful geyser eruptions data from][]{vcd:Azzalini+Bowman:1990}---other typical applications
include objective functions with two arguments \citep[as in][]{vcd:Gneiting+Sevcikova+Percival:2006}
or (physical) measurements on a 2-dimensional grid \citep[as in][]{vcd:Yang+Buckley+Dudoit:2002}.
Figure~\ref{fig:bkde} shows such a heatmap bringing out the relationship between the duration
of an eruption of the Old Faithful geyser in Yellowstone National Park 
and the waiting time for this eruption. It reveals a multi-modal distribution: short waiting
times (around 50 minutes) are typically followed by a long eruption (around 4 minutes)
whereas long waiting times (around 80 minutes) can be followed by either a long
or short eruption (around 4 minutes). 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<bkde>>=
if(generate_png) {
  data("geyser", package = "MASS")
  ## geyser2 <- cbind(geyser$duration[-299], geyser$waiting[-1])
  geyser2 <- cbind(geyser$duration, geyser$waiting)
  dens <- bkde2D(geyser2, bandwidth = c(0.2, 3), gridsize = c(201, 201))
  plot_bkde2D <- function(x, col = NULL, xlab = "duration", ylab = "waiting time", legend = FALSE, ...) {
    if(is.null(col)) col <- rev(grey.colors(33))
    if(legend) {
      filled.contour(x$x1, x$x2, x$fhat, col = col, nlevels = length(col), xlab = xlab, ylab = ylab, ...)
    } else {
      image(x$x1, x$x2, x$fhat,
        breaks = seq(from = min(x$fhat), to = max(x$fhat), length.out = length(col) + 1),
        xlab = xlab, ylab = ylab, col = col, axes = FALSE, cex.lab = 1.5, ...)
      box()
      axis(1, cex.axis = 1.5)
      axis(2, cex.axis = 1.5)
    }
    invisible(x)
  }

  png(file = "bkde.png", height = 810, width = 840)
  par(mfrow = c(2, 2))
  plot_bkde2D(dens, col = hsv(seq(from = 2/3, to = 0, length = 33), 0.8, 0.9))
  ## plot_bkde2D(dens, col = rainbow(33, start = 1/3, end = 1, v = 0.8, s = 0.9))
  plot_bkde2D(dens, col = rev(sequential_hcl(33, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  plot_bkde2D(dens, col = rev(heat.colors(33)))
  plot_bkde2D(dens, col = rev(heat_hcl(33, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  dev.off()
}
@
\includegraphics{bkde}
\setkeys{Gin}{width=.47\textwidth}
<<bkde-pal>>=
if(generate_png) {
  png(file = "bkde-pal.png", height = 160, width = 396)
  par(mfrow = c(4, 1), mar = c(0, 0, 0, 0), oma = c(2, 1.5, 0, 1.5))
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    hsv(seq(from = 2/3, to = 0, length = 99), 0.8, 0.9))
    ## rainbow(99, start = 1/3, end = 1, v = 0.8, s = 0.9))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat.colors(99)))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat_hcl(99, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(sequential_hcl(99, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  box()
  axis(1, cex.axis = 1.5)
  dev.off()
}
@
\includegraphics{bkde-pal}
\caption{\label{fig:bkde} Bivariate density estimation for Old Faithful geyser eruptions.}
\end{center}
\end{figure}

A simple and very effective palette for such a display is a set of gray colors
as in the top right panel of Figure~\ref{fig:bkde}. This is often (appropriately) used
in printed papers when the journal does not offer color graphics---however, in journals
that support color graphics, on presentation slides and in interactive usage (in statistical
software packages), many users prefer to have colored displays and most often HSV
palettes (as in the left two panels) are used. These palettes code the variable of interest
by varying hue in an HSV color wheel as done by \citet[Figure~4a]{vcd:Yang+Buckley+Dudoit:2002}
or \citet[Figures~1--4]{vcd:Gneiting+Sevcikova+Percival:2006}. The palette in the upper left panel
codes increasing density by going from a blue to a red hue (via green and yellow)---a similar
strategy are the ``heat colors'' in the lower left panel that increase from yellow to red.
The latter works a bit better than the former, however both palettes exhibit several drawbacks.
The modes in the map look much more like ``rings'' than a smoothly increasing/decreasing 
density. The heatmap looks very flashy which---although good for drawing attention to a plot---makes
it hard to hold the attention of the viewer for a longer time because the large areas shaded
with saturated colors can be distracting and produce after-image effects \citep{vcd:Ihaka:2003}.

In contrast, the gray colors used in the top right panel do not exhibit the same disadvantages,
coding the variable of interest much better and without flashy colors. If, however, the user wants
to add some color to the plot, this could be done by using a better balanced version of the heat
colors (as shown in the bottom right panel). These colors also increase from a yellow to a red
hue while being balanced towards the same gray as in the grayscale palette (i.e., when converted
to a grayscale or printed out on a grayscale printer, the upper and lower right panel would 
essentially look identical). Both palettes have in common that they give increasing perceptual emphasis
to regions with increasing density, resulting in a heatmap that highlights the (small)
interesting high-density regions and not to the large low-density regions surrounding them.


To illustrate sequential palettes, 

 Both versions of the heatmap use a sequential
palette as derived in Section~\ref{sec:sequential} balanced towards the same gray levels
with $L \in [30, 90]$ and $p_2 = 1.5$. The sequential palette in the left panel uses only gray
colors (i.e., $C_{\max} = 0$) and the palette in the right panel additionally employs
colors with $H \in [0, 90]$, $C \in [30, 80]$ and $p_1 = 1/5$. The parameters have been 
chosen such that the peaks in the density are brought out very clearly by using a rather
large luminance contrast and $p_2 > 1$.



\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<nigeria>>=
if(generate_png) {
  m <- read.bnd("Nigeria/nigeria37.bnd")
  fit <- read.table("Nigeria/reml_purespatial_f_district_spatial.res", header = TRUE)
  fit <- fit[order(fit$district),]

  png(file = "nigeria.png", height = 400, width = 840)
  par(mfrow = c(1, 2), mar = c(2.22, 0.22, 1.02, 0.22))
  plot(m, z = fit$pmode, fill = rev(rainbow(99, start = 0, end = 1/3)),
    zlim = c(-0.65, 0.65), legend = FALSE)
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  dev.off()
}
@
\includegraphics{nigeria}
\setkeys{Gin}{width=.47\textwidth}
<<nigeria-pal>>=
if(generate_png) {
  png(file = "nigeria-pal.png", height = 80, width = 396)
  par(mfrow = c(2, 1), mar = c(0, 0, 0, 0), oma = c(2, 0.2, 0, 0.2))
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(rainbow(99, start = 0, end = 1/3)))
  box()
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  box()
  axis(1, cex = 1.5)
  dev.off()
}
@
\includegraphics{nigeria-pal}
\caption{\label{fig:nigeria} Posterior mode estimates for childhood mortality in Nigeria.}
\end{center}
\end{figure}

Figure~\ref{fig:nigeria} is taken from \citep[Figure~5, left]{vcd:Kneib:2006}


\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<seats, fig=TRUE, height=4, width=11>>=
par(mar = rep(0.8, 4), mfrow = c(1, 2))
seats <- structure(c(226, 61, 54, 51, 222),
  .Names = c("CDU/CSU", "FDP",  "Linke", "Gruene", "SPD"))
parties_hcl <- rainbow_hcl(6, c = 60, l = 75)[c(5, 2, 6, 3, 1)]
parties_hsv <- hsv(c(0, 60, 300, 120, 0)/360, v = c(0, 1, 1, 1, 1))
names(parties_hcl) <- names(parties_hsv) <- names(seats)
names(seats)[4] <- "Grüne"
pie(seats, clockwise = TRUE, col = parties_hsv, radius = 1)
pie(seats, clockwise = TRUE, col = parties_hcl, radius = 1)
@
\caption{\label{fig:seats} Seats in the German parliament.}
\end{center}
\end{figure}

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<votes, fig=TRUE, height=6, width=14>>=
data("Bundestag2005")
votes <- Bundestag2005[c(1, 3:5, 9, 11, 13:16, 2, 6:8, 10, 12),
                       c("CDU/CSU", "FDP", "SPD", "Gruene", "Linke")]
parties_hcl <- parties_hcl[colnames(votes)]
parties_hsv <- parties_hsv[colnames(votes)]
dimnames(votes)[[2]][c(4, 5)] <- c("Gr", "Li")

grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
mosaic(votes, gp = gpar(fill = parties_hsv),
  spacing = spacing_highlighting, labeling = labeling_left,
  labeling_args = list(rot_labels = c(0, 90, 0, 0), pos_labels = "center",
  just_labels = c("center","center","center","right"), varnames = FALSE),
  margins = unit(c(2.5, 1, 1, 12), "lines"),
  keep_aspect_ratio = FALSE, newpage = FALSE)
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row=1))
mosaic(votes, gp = gpar(fill = parties_hcl),
  spacing = spacing_highlighting, labeling = labeling_left,
  labeling_args = list(rot_labels = c(0, 90, 0, 0), pos_labels = "center",
  just_labels = c("center","center","center","right"), varnames = FALSE),
  margins = unit(c(2.5, 1, 1, 12), "lines"),
  keep_aspect_ratio = FALSE, newpage = FALSE)
popViewport(2)
@
\caption{\label{fig:votes} Votes in the German election 2005 (by province).}
\end{center}
\end{figure}

The first example illustrates qualitative palettes
and visualizes data from the 2005 election for the German parliament ``Bundestag''.
In this election, five parties were able to obtain enough votes to enter the
Bundestag---the distribution of seats is depicted in a pie chart in Figure~\ref{fig:seats}.
The colors used are rough metaphors for the political parties, using a red hue $H = 0$ for the
social democrats SPD, a blue hue $H = 240$ for the conservative CDU/CSU, a yellow hue $H = 60$
for the liberal FDP, a green hue $H = 120$ for the green party ``Die Gr\"unen'' and a purple 
hue $H = 300$ for the leftist party ``Die Linke''. To obtain rather intense colors, we set
chroma to $C = 60$ and luminance to $L = 75$ for all hues
leading to a much better balanced palette compared to the fully saturated
colors usually found in the (German) media (which instead of blue typically use the extreme
``color'' black for the CDU/CSU). The pie chart clearly shows that neither the governing
coalition of SPD and Gr\"une nor the opposition of CDU/CSU and FDP could assemble a majority.
Given that no party would enter a coalition with the leftists, this lead to a big coalition
of CDU/CSU and SPD. Figure~\ref{fig:votes} shows the distribution of votes in this election
stratified by province (Bundesland) in a highlighted mosaic display. The order of provinces is from 
north to south, first for the 10 western provinces (the former Federal Republic of Germany, FRG),
then for the 6 eastern provinces (the former German Democratic Republic, GDR). 
Clearly, the SPD performed better in the north and the CDU/CSU better in the south; furthermore,
Die Linke performed particularly well in the eastern provinces and in Saarland.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<scatter>>=
if(generate_png) {
  set.seed(123)
  vc <- function(var1, var2, cov)
    matrix(c(var1, cov * sqrt(var1 * var2), cov * sqrt(var1 * var2), var2), ncol = 2)
  dat <- rbind(rmvnorm(1000, c(0, 0), vc(0.05, 0.3, -0.95)),
               rmvnorm(1000, c(1.8, 2.5), vc(0.12, 0.25, 0)),
               rmvnorm(1000, c(3.8, 3.5), vc(0.02, 0.15, -0.8)))
  dat <- data.frame(y = dat[,2], x = dat[,1], id = rep(1:3, rep(1000, 3)))

  png(file = "scatter.png", height = 350, width = 840)
  par(mfrow = c(1, 2), mar = rep(0.5, 4))
  plot(y ~ x, data = dat, axes = FALSE, xlab = "", ylab = "", pch = c(3, 22, 1)[id],
    col = hsv(c(1/3, 1/6, 0))[id])
  box()
  plot(y ~ x, data = dat, axes = FALSE, xlab = "", ylab = "", pch = c(3, 22, 1)[id],
    col = hcl2hex(c(120, 60, 0), 70, 65, fix = FALSE)[id])
  box()
  dev.off()
}
@
\includegraphics{scatter}
\caption{\label{fig:scatter} Scatter plot with three clusters.}
\end{center}
\end{figure}

similar to \citet[Figure~3]{vcd:Celeux+Hurn+Robert:2000}

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<haireye, fig=TRUE, height=5.5, width=12>>=
he <- margin.table(HairEyeColor, 1:2)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
mosaic(he, gp = shading_hsv, split_vertical = TRUE, newpage = FALSE, legend = FALSE)
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row=1))
mosaic(he, gp = shading_hcl, split_vertical = TRUE, newpage = FALSE, legend = FALSE)
popViewport(2)
@
\caption{\label{fig:haireye} Extended mosaic display for haireye data.}
\end{center}
\end{figure}

taken from \citet[Figure~11, left/middle]{vcd:Friendly:2002}


As pointed out in Section~\ref{sec:diverging}, diverging palettes are particularly useful
when visualizing residuals or correlations (with natural neutral value 0) or probabilities 
in 2-class supervised learning (with neutral value 0.5). Examples for both situations are
provided here. Figure~\ref{fig:haireye} visualizes the outcome of a double-blind clinical
trial investigating a new treatment for rheumatoid arthritis. The mosaic rectangles alone
signal that the treatment lead to higher improvement compared to the placebo group; this effect
is shown to be significant by the shading that codes the size of the Pearon residuals.
Positive residuals, corresponding
to more observations in the corresponding cell than expected under independence, are depicted
in blue, negative residuals in red. Light colors signal significance at 10\% level, full colors
significance at 1\% level. Hence, it can be concluded that there are significantly more
marked improvements in the treated group and significantly fewer in the placebo group than
would be expected under independence between treatment and improvement. More details can
be found in \cite{vcd:Zeileis+Meyer+Hornik:2007}.

Both diverging palettes employ a smaller contrast on the luminance axis ($L \in [50, 90]$)
and a larger chroma contrast ($C \in [0, 100]$) compared to the sequential palettes from
the previous example. 
For Figure~\ref{fig:haireye}, the choice of
$p_1$ and $p_2$ is less important because only 5 colors are selected---we use values
$p_1 = p_2 = 1$.







\section{Color spaces} \label{sec:spaces}

For choosing color palettes it is helpful to have an idea how
human color vision evolved. It has been hypothesized that it developed in three
distinct stages: 1.~perception of \emph{light/dark} contrasts (monochrome only),
2.~\emph{yellow/blue} contrasts (usually associated with our notion of warm/cold colors),
3.~\emph{green/red} contrasts (helpful for assessing the ripeness of fruit). See 
\cite{vcd:Ihaka:2003} for more details and references.

Due to these three color axes, colors are typically described as
locations in 3-dimensional spaces. However, human perception of color
does not correspond to the physiological axes above, but rather to polar
coordinates in the color plane (yellow/blue vs.~green/red) plus a third
light/dark axis. Thus, perceptually-based color spaces try to capture the
perceptual axes
\begin{itemize}
  \item \emph{hue} (dominant wavelength)
  \item \emph{chroma} (colorfulness, intensity of color as compared to gray)
  \item \emph{luminance} (brightness, amount of gray)
\end{itemize}

A popular implementation of such a color space, available in many graphics and
statistics software packages, are HSV colors. They are a simple transformation of RGB colors
and are defined by a triplet $(H, S, V)$ with $H \in [0, 360]$ and $S, V \in [0, 100]$.
%% HSV space has the shape of a single regular cone (often inflated to a regular
%% cylinder). Vertical sections through this space are shown in the upper panel
%% of Figure~\ref{fig:hsv-hcl}, depicting hue and saturation given different value levels.
Although simple to specify and easily available in many computing environments,
HSV colors have a fundamental drawback: its three dimensions map to the three
dimensions of human color perception very poorly. The three dimensions are
confounded:
%% which is most easily seen when converting the vertical sections to 
%% gray scale images in Figure~\ref{fig:hsv-hcl-gray}. Clearly,
the brightness of
colors is not uniform over hues and saturations (given value)---therefore,
HSV colors are often not considered to be perceptually based.

To overcome these drawbacks, various color spaces have been suggested
that properly map to the perception dimensions, the most prominent of which are
the CIELUV and CIELAB spaces developed by the \cite{vcd:CIE:2004}. \cite{vcd:Ihaka:2003}
argues that CIELUV colors are typically preferred for use with emissive technologies
such as computer screens which makes them an obvious candidate for implementation
in statistical software packages. By taking polar coordinates in the UV plane of
CIELUV, HCL colors are obtained, defined by
a triplet $(H, C, L)$ with $H \in [0, 360]$ and $C, L \in [0, 100]$.
%% HCL space has the shape of a distorted double cone: the admissible combinations of
%% chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
%% The lower panel of Figure~\ref{fig:hsv-hcl} shows
%% vertical sections through this space: each of the resulting hue/chroma planes (given
%% luminance) is now properly balanced towards the same gray (going from black to white
%% with increasing luminance) which becomes obvious when converting the colors to
%% a gray scale as in Figure~\ref{fig:hsv-hcl-gray}. 
Given a certain luminance $L$, all colors resulting from different combinations
of hue $H$ and chroma $C$ are balanced towards the same gray (and look the same
when converted to a gray scale). However, the admissible combinations of
chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
The reason for this is that some hues lead to light and others to dark colors,
e.g., full chroma yellow is brighter (i.e., has higher luminance) than full chroma blue.

The balancing of HCL colors
gives us the opportunity to conveniently choose color palettes which code categorical
and/or numerical information by translating it to paths along the three perceptual axes.
However, some care is required for dealing with the irregular shape of the HCL space
which will be addressed in the following sections.

\section{Color palettes} \label{sec:palettes}

\subsection{Qualitative palettes} \label{sec:qualitative}

Qualitative palettes are sets of colors for depicting different categories,
i.e., for coding a categorical variable. Usually, these should give the same
perceptual weight to each category so that no group is perceived to be larger or more
important than any other one. Typical applications of qualitative palettes in
statistics would be bar plots \citep[see][]{vcd:Ihaka:2003}, pie charts (see Figure~\ref{fig:seats}) 
or highlighted mosaic displays (see Figure~\ref{fig:votes}).

\cite{vcd:Ihaka:2003} describes a simple strategy for choosing such palettes: chroma
and luminance are kept fixed and only the hue is varied for obtaining different colors
which are consequently all balanced towards the same gray. As Figure~\ref{fig:hsv-hcl}
illustrates, the range of hues available depends on the combination of chroma and
luminance chosen. Figure~\ref{fig:pal-q-construct} depicts how three colors
are chosen, given $C = 50$ and $L = 70$. 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<wheel, fig=TRUE, height=4, width=11>>=
par(mar = rep(0.8, 4), mfrow = c(1, 2))
par(mfrow = c(1,2), mar = c(1,1,1,1), oma = c(0,0,0,0))
pie(rep(1,6), radius = 1, col = rainbow(6), labels = 360 * 0:5/6)
pie(rep(1,6), radius = 1, col = rainbow_hcl(6, c = 50, l = 70), labels = 360 * 0:5/6)
@
\caption{\label{fig:wheel} HSV-based and HCL-based color wheel.}
\end{center}
\end{figure}


Various strategies for choosing the hues in a certain palette are conceivable.
A simple and intuitive one is to use colors as metaphors for categories
(e.g., for political parties), another approach would be to use segments from
the color wheel corresponding to nearby or distant colors. The latter is shown
in Figure~\ref{fig:pal-q-examples} which depicts
examples for generating qualitative sets of colors $(H, 50, 70)$.
In the upper left panel colors from the full spectrum are used ($H = 30, 120, 210, 300$)
creating a `dynamic' set of colors. The upper right panel shows a `harmonic'
set with $H = 60, 120, 180, 240$. Warm colors (from the blue/green part of the spectrum: 
$H = 270, 230, 190, 150$) and cold colors (from the yellow/red part of the spectrum:
$H = 90, 50, 10, 330$) are shown in the lower left and right panel, respectively.

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-construct>>=
if(generate_png) {
  png(file = "pal-q-construct.png", height = 480, width = 480)
  hcl.wheel(luminance = 70, do.label = FALSE, inner.circle = TRUE)
  rect(0.45, -0.05, 0.55, 0.05, col = hcl2hex(0, 50, 70))
  rect(-cos(pi/3)/2-0.05, sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, sin(pi/3)/2+0.05, col = hcl2hex(120, 50, 70))
  rect(-cos(pi/3)/2-0.05, -sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, -sin(pi/3)/2+0.05, col = hcl2hex(240, 50, 70))
  dev.off()
}
@
\includegraphics{pal-q-construct}
\vspace*{-2cm}
\caption{\label{fig:pal-q-construct} Constructing qualitative palettes. In the hue/chroma
plane for $L = 70$, the dashed circle correponds to a radius $C = 50$ with chosen angles
$H = 0, 120, 240$.}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(2, 2), mar = c(0, 0, 3, 2))
pal(rainbow_hcl(4, start = 30, end = 300), main = "dynamic [30, 300]")
pal(rainbow_hcl(4, start = 60, end = 240), main = "harmonic [60, 240]")
pal(rainbow_hcl(4, start = 270, end = 150), main = "cold [270, 150]")
pal(rainbow_hcl(4, start = 90, end = -30), main = "warm [90, -30]")
@
\caption{\label{fig:pal-q-examples} Examples for qualitative palettes. Hue is varied
in different intervals for given $C = 50$ and $L = 70$.}
\end{center}
\end{figure}


\subsection{Sequential palettes} \label{sec:sequential}

Sequential palettes are used for coding numerical information that ranges
in a certain interval where low values are considered to be uninteresting and
high values are interesting. Suppose we need to visualize an intensity or
interestingness $i$ which (without loss of generality) is scaled to the unit
interval. A typical application in statistics are heatmaps (see Figure~\ref{fig:bkde}).

The simplest solution to this task is to employ light/dark contrasts, i.e., rely
on the most basic perceptual axis. The interestingness can be coded
by an increasing amount of gray corresponding to decreasing luminance in HCL space:
  \[ (H, 0, 90 - i \cdot 60), \]
where the hue $H$ used does not matter, chroma is set to 0 (i.e., no color), and 
luminance ranges in $[30, 90]$ avoiding the extreme colors white ($L = 100$) and 
black ($L = 0$). Instead of going linearly from light to dark gray, luminance
could also be increased nonlinearly, e.g., by some function $f(i)$ that
controls whether luminance is increased quickly with intensity or not. We found $f(i) = i^p$ 
to be a convenient transformation where the power $p$ can be varied to achieve
different degrees of non-linearity.

Furthermore, the intensity $i$ could additionally be coded by colorfulness (chroma), e.g.,
  \[ (H, 0 + i^p \cdot C_{\max}, L_{\max} - i^p \cdot (L_{\max} - L_{\min})). \]
This strategy is depicted in the left panel of Figure~\ref{fig:pal-s-construct} for a blue
hue $H = 260$ and different combinations of maximal chroma ($C_{\max} = 0$, $80$ and $100$,
respecitvely) and minimal luminance ($L_{\min} = 30$, $30$ and $50$, respectively).
The first two combinations are also shown in the first two rows of Figure~\ref{fig:pal-s-examples}.
The right panel of Figure~\ref{fig:pal-s-construct} shows that the exact same strategy
is not possible  for the green hue $H = 120$. While the gray colors without chroma can be chosen in 
the same way, there is a stronger trade-off between using dark colors (with low luminance)
and colorful colors (with high chroma). Hence, the second path from light gray to 
full green ends at a much lighter color with $L_{\min} = 75$. 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-construct>>=
if(generate_png) {
  png(file = "pal-s-construct.png", height = 420, width = 840)
  par(mfrow = c(1, 2))
  hue.slice(260, grid.n = 301)
  lines(c(0, 100), c(90, 50), lty = 2)
  lines(c(0, 80), c(90, 30), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 67.5, 52.5, 72.5, col = hcl2hex(260, 50, 70))
  rect(95, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  rect(37.5, 57.5, 42.5, 62.5, col = hcl2hex(260, 40, 60))
  rect(77.5, 27.5, 82.5, 32.5, col = hcl2hex(260, 80, 30))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  hue.slice(120, grid.n = 301)
  lines(c(0, 100), c(90, 75), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 80, 52.5, 85, col = hcl2hex(120, 50, 82.5))
  rect(95, 72.5, 100, 77.5, col = hcl2hex(120, 100, 75))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  dev.off()
}
@
\includegraphics{pal-s-construct}
\caption{\label{fig:pal-s-construct} Constructing sequential palettes. The chroma/luminance
plane is shown for two hues $H = 260$ (left) and $H = 120$ (right). Colors are chosen by varying
either only luminance or both luminance and chroma.}
\end{center}
\end{figure}

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-examples, fig=TRUE, height=5, width=6>>=
par(mfrow = c(5, 1), mar = c(0.25, 0, 0.25, 0))
pal(sequential_hcl(12, c = 0, power = 2.2))
pal(sequential_hcl(12, power = 2.2))
pal(heat_hcl(12, c = c(80, 30), l = c(30, 90), power = c(1/5, 2)))
pal(terrain_hcl(12, c = c(65, 0), l = c(45, 90), power = c(1/2, 1.5)))
pal(rev(heat_hcl(12, h = c(0, -100), l = c(75, 40), c = c(40, 80), power = 1)))
@
\caption{\label{fig:pal-s-examples} Examples for sequential palettes, varying
only luminance (first panel), chroma and luminance (second panel), and hue,
chroma and luminance (remaining panels).}
\end{center}
\end{figure}

To increase the contrast between the colors in the palette even further, the ideas from
the previous sequential palettes can also be combined with qualitative palettes by
simultaneously varying the hue as well:
  \[ (H_2 - i \cdot (H_1 - H_2), C_{\max} - i^{p_1} \cdot (C_{\max} - C_{\min}),
      L_{\max} - i^{p_2} \cdot (L_{\max} - L_{\min})). \]
One application would be an HCL-based version of ``heat colors'' that increase from a light yellow
(e.g., $(90, 30, 90)$) to a full red (e.g., $(0, 100, 50)$). To make the change in hue
visible, the chroma needs to increase rather quickly for low values of $i$ and then only
slowly for higher values of $i$. This can be achieved by choosing a power $p_1 < 1$.
Such a strategy is adopted for the palettes shown in the lower three rows in
Figure~\ref{fig:pal-s-examples} using different pairs of hues as well as different
chroma and luminance contrasts. The exact parameter combinations are provided in the
appendix.


\subsection{Diverging palettes} \label{sec:diverging}

Diverging palettes are also used for coding numerical information ranging in a certain
interval---however, this interval includes a neutral value. Examples for this include
residuals or correlations (both with the neutral value 0) or binary classification
probabilities (with neutral value 0.5) that could be visualized in mosaic plots (see Figure~\ref{fig:haireye})
or classification maps (see Figure~\ref{fig:class}). Analogously to the previous
section, we suppose that we want to visualize an intensity or interestingness $i$
from the interval $[-1, 1]$ (without loss of generality).

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-construct>>=
if(generate_png) {
  png(file = "pal-d-construct.png", height = 480, width = 534)
  hue260 <- hue.slice(260, grid.n = 301, plot = FALSE)
  hue360 <- hue.slice(360, grid.n = 301, plot = FALSE)
  mychroma <- as.numeric(colnames(hue260))
  luminance <- as.numeric(rownames(hue260))
  nc <- ncol(hue260)
  nl <- nrow(hue260)
  plot(0.5, 0.5, xlim = c(-100, 100), ylim = c(0, 100), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
  for(i in 1:(nc-1)) {
    rect(mychroma[i], luminance[-nl], mychroma[i] + 100/(nc-1), luminance[-1], border = hue260[,i+1], col = hue260[,i+1])
  }
  for(i in 1:(nc-1)) {
    rect(-mychroma[i], luminance[-nl], -(mychroma[i] + 100/(nc-1)), luminance[-1], border = hue360[,i+1], col = hue360[,i+1])
  }
  axis(1, labels = FALSE, at = c(-100, 0, 100))
  axis(2, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  axis(3, at = -4:4*25, labels=c(4:0*25, 1:4*25))
  axis(4, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  mtext(c("hue = 0", "hue = 260"), side = 3, at = c(-50, 50), line = 3, cex = 1.2)
  mtext("chroma", side = 3, at = 0, line = 2)
  mtext("luminance", side = 2, at = 50, line = 2)
  mtext("luminance", side = 4, at = 50, line = 2)
  lines(c(-100, 0, 100), c(50, 90, 50), lty = 2)
  rect(-100, 47.5, -90, 52.5, col = hcl2hex(0, 100, 50))
  rect(-55, 67.5, -45, 72.5, col = hcl2hex(0, 50, 70))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(45, 67.5, 55, 72.5, col = hcl2hex(260, 50, 70))
  rect(90, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  lines(c(-80, 0, 80), c(30, 90, 30), lty = 2)
  rect(-85, 27.5, -75, 32.5, col = hcl2hex(0, 80, 30))
  rect(-45, 57.5, -35, 62.5, col = hcl2hex(0, 40, 60))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(35, 57.5, 45, 62.5, col = hcl2hex(260, 40, 60))
  rect(75, 27.5, 85, 32.5, col = hcl2hex(260, 80, 30))
  dev.off()
}
@
\includegraphics{pal-d-construct}
\caption{\label{fig:pal-d-construct} Constructing diverging palettes. The chroma/luminance
plane is shown back to back hues $H = 0$ and $H = 260$. Colors are chosen by simultaneously 
varying luminance and chroma.}
\end{center}
\end{figure}


\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(4, 1), mar = c(0.25, 0, 0.25, 0))
pal(diverge_hcl(7))
pal(diverge_hcl(7, c = 100, l = c(50, 90), power = 1))
pal(diverge_hcl(7, h = c(130, 43), c = 100, l = c(70, 90)))
pal(diverge_hcl(7, h = c(180, 330), c = 59, l = c(75, 95)))
@
\caption{\label{fig:pal-d-examples} Examples for diverging palettes with different
pairs of hues and decreasing luminance contrasts.}
\end{center}
\end{figure}

Given useful sequential palettes, deriving diverging palettes is easy: two different hues are
chosen for adding color to the same amount of `gray' at a given intensity $|i|$.
Figure~\ref{fig:pal-d-construct} shows the chroma/luminance plane back to back for the
hues $H = 0$ and 260 with two different paths---giving slightly different emphasis on
luminance or chroma contrasts---from a full red over a neutral grey to a full blue.
As Figure~\ref{fig:pal-s-construct} illustrates, the pair of hues should be chosen carefully
because the admissible values in the chrome/luminance plane differ across hues.
Clearly, for deriving symmetric palettes, only colors from the intersection of the
admissible chroma/luminance planes can be used. The particular hues $H = 0$ and $260$
used in Figure~\ref{fig:pal-d-construct} were chosen because they correspond to similar
geometric shapes in the chroma/luminance plane, allowing for both large chroma and
luminance contrasts. If potential viewers of the resulting graphic might be color-blind,
the pair of hues should be taken from the yellow/blue axis of the color wheel
rather than the green/red axis as contrasts on the latter axis are more difficult to 
distinguish for color-blind people \citep{vcd:Lumley:2006}.

%%FIXME: comment on vcd:Lumley:2006

Figure~\ref{fig:pal-d-examples} shows various examples of conceivable combinations of
hue, chroma and luminance. The first palette uses a broader range on the luminance axis
whereas the others mostly rely on chroma contrasts.


\section{Software} \label{sec:software}

Implementing the different color palettes suggested in the previous section 
is extremely easy if the software environment chosen already provides an implementation
of HCL colors: from the formulas provided above the HCL coordinates for a
palette can be conveniently computed. A bit more work is required if the software
package does not yet provide an HCL implementation. In that case, additional
functionality is needed for translating HCL coordinates to the software package's 
color system which may vary between different packages, but standardized RGB (sRGB)
is often used. The typical way of coordinate conversion is to go first from HCL to
CIELUV by simply transforming the polar $H$ and $C$ coordinates back to the original
$U$ and $V$. Subsequently, CIELUV is converted to CIEXYZ which in turn is converted
to sRGB (with the latter conversion depending on the device used for display).
The details of these conversions are somewhat technical and tedious (and hence
omitted here), however the conversion formulas are still straightfoward to
implement and can, for example, be found in \cite{vcd:Wiki+LUV:2006} or
\cite{vcd:Poynton:2000}.

The \proglang{R} system for statistical computing \citep{vcd:R:2006} already comes
with an open-source implementation of HCL (and other color spaces) in the package
\pkg{colorspace} \citep{vcd:Ihaka:2006} which we build upon for implementing all
palettes described above. The functions outlined below are provided by the package
\pkg{vcd} \citep{vcd:Meyer+Zeileis+Hornik:2006}---technical documentation for
the functions along with a large collection of examples is available via
\verb/help("rainbow_hcl")/. These examples also include comparisons between
existing \proglang{R} palettes (based on HSV colors) and the new HCL color palettes.

Qualitative palettes are implemented in \pkg{vcd} in the function
\begin{Soutput}
rainbow_hcl(n, c = 50, l = 70, start = 0, end = 360*(n-1)/n, ...)
\end{Soutput}
where \code{n} controls the number of colors in the palette. The arguments
\code{c} and \code{l} give the fixed chroma and luminance levels, respectively,
and \code{start} and \code{end} specify the range of hue angles. The function
is named after the base \proglang{R} function \code{rainbow()} which has a similar
interface but chooses colors in HSV coordinates. It computes the HCL coordinates
and transforms them to RGB by using the \code{hcl2hex()} function which
is a convenience wrapper to the function \code{polarLUV()} from
the \pkg{colorspace} package. 

Sequential palettes based on a single hue are implemented in the function
\begin{Soutput}
sequential_hcl(n, h = 260, c = c(80, 0), l = c(30, 90), power = 1.5, ...) 
\end{Soutput}
where the first element of \code{c} and \code{l} give the starting chroma and luminance
coordinate (by default colorful and dark) and the second element the ending coordinate
(by default light gray). The \code{power} argument implements the parameter $p$ 
from the $i^p$ function. Sequential palettes using a range of hues are provided by
\begin{Soutput}
heat_hcl(n, h = c(0, 90), c = c(100, 30), l = c(50, 90), power = c(1/5, 1), ...)
\end{Soutput}
named after the HSV-based \proglang{R} function \code{heat.colors()} and
by default starts from a red and going to a yellow hue. The defaults in \code{heat_hcl()}
are set differently compared to \code{sequential_hcl()} as to make the default HCL heat
colors more similar to the HSV version. The defaults of \code{sequential_hcl()}, on the
other hand, are set as to achieve a large contrast on the luminance axis.

Diverging palettes are implemented in the function
\begin{Soutput}
diverge_hcl(n, h = c(260, 0), c = 80, l = c(30, 90), power = 1.5, ...) 
\end{Soutput}
which has the same arguments as \code{sequential_hcl()} but takes a pair of hues \code{h}.

The \proglang{R} code for reproducing
Figures~\ref{fig:pal-q-examples}, \ref{fig:pal-s-examples} and \ref{fig:pal-d-examples}
is given in the appendix. A vignette that additionally explains how the figures from the illustrations
section can be reproduced is contained in \pkg{vcd} and be accessed via
\code{vignette("hcl-colors", package = "vcd")}.


\section{Discussion} \label{sec:discussion}

Many statistical graphics---especially when displayed on a computer screen,
e.g., as in interactive usage, electronic papers or presentation slides---
employ colors to code information about a certain variable. Despite this
omnipresence of color, there is often only little guidance in statistical
software packages on how to choose a palette appropriate for a particular
visualization task---auspicious tools such as \pkg{ColorBrewer.org} notwithstanding.
We try to address this problem by suggesting color schemes for coding
categorical information (qualitative palettes) and numerical information
(sequential and diverging palettes) based on the perceptually-based
HCL color space.

We provide paths through HCL space along perceptual axes
so that colors selected along these paths match perceptual dimensions.
This gives the users the possibility to conveniently experiment with the HCL-based
palettes by varying several graphical parameters. For qualitative
palettes, these are the coordinates on the chroma and luminance axis, respectively,
controlling whether the colors are light or dark and how colorful they are.
For sequential and diverging palettes, the user can decide whether contrasts
in the chroma or luminance direction (or both) should be employed. In our
experience (as illustrated in Section~\ref{sec:motivation}), chroma contrasts
work sufficiently well if a small set of colors is used. However, when a larger
set of colors is used (e.g., for heatmaps where extreme values should be identifiable)
it is much more important to have a big difference in luminance. Another parameter in these 
palettes is the rate at which the intensity $|i|$ is increased from $0$ to $1$:
Employing a function $|i|^p$ for this, small
powers $p$ can be used if palettes with a lot of color should be 
constructed (e.g., to clearly separate regions in a classification map). On
the other hand, large powers $p$ will result in palettes with less color
(e.g., appropriate to highlight only extreme regions firmly classified in such a map).

Based on these conceputal guidelines and the computational tools readily
provided in the \proglang{R} system for statistical computing (and easily implemented in other
statistical software packages), users can generate palettes varying these
graphical parameters and thus adapting the colors to their particular graphical display.


\section*{Acknowledgements}

We are thankful to David Meyer, Paul Murrell, Brian~D.~Ripley,
Thomas Kneib, and Michael H\"ohle for feedback, suggestions and discussions.

\bibliography{vcd}

\begin{appendix}

\section[Supplementary R code]{Supplementary \proglang{R} code}
\label{sec:R}

All palettes discussed above are implemented in the \proglang{R} system for statistical
computing and graphics \citep{vcd:R:2006} in the package 
\pkg{vcd} \citep{vcd:Meyer+Zeileis+Hornik:2006}. The functions are based on the
\code{polarLUV(l, c, h)} function proveded by the \pkg{colorspace} package
\citep{vcd:Ihaka:2006}.
A simple convenience function for displaying a certain palette is
\begin{Soutput}
pal <- function(col, border = "light gray", ...)
{
  n <- length(col)
  plot(0, 0, type = "n", xlim = c(0, 1), ylim = c(0, 1),
       axes = FALSE, xlab = "", ylab = "", ...)
  rect(0:(n-1)/n, 0, 1:n/n, 1, col = col, border = border)
}
\end{Soutput}

The qualitative palettes in Figure~\ref{fig:pal-q-examples} are generated via
\begin{Soutput}
pal(rainbow_hcl(4, start =  30, end = 300))
pal(rainbow_hcl(4, start =  60, end = 240))
pal(rainbow_hcl(4, start = 270, end = 150))
pal(rainbow_hcl(4, start =  90, end = -30))
\end{Soutput}

The sequential palettes in Figure~\ref{fig:pal-s-examples} are generated via
\begin{Soutput}
pal(sequential_hcl(12, c = 0, power = 2.2))
pal(sequential_hcl(12, power = 2.2))
pal(heat_hcl(12, c = c(80, 30), l = c(30, 90), power = c(1/5, 2)))
pal(terrain_hcl(12, c = c(65, 0), l = c(45, 90), power = c(1/2, 1.5)))
pal(heat_hcl(12, h = c(0, -100), l = c(75, 40), c = c(40, 80), power = 1))
\end{Soutput}

The diverging palettes in Figure~\ref{fig:pal-d-examples} are generated via
\begin{Soutput}
pal(diverge_hcl(7))
pal(diverge_hcl(7, c = 100, l = c(50, 90), power = 1))
pal(diverge_hcl(7, h = c(130, 43), c = 100, l = c(70, 90)))
pal(diverge_hcl(7, h = c(180, 330), c = 59, l = c(75, 95)))
\end{Soutput}

Further examples and technical information on all palettes is available from
the corresponding online documentation.

\end{appendix}

\end{document}
