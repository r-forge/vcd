\documentclass{Z}
%% need no \usepackage{Sweave}
\SweaveOpts{engine=R, eps=FALSE, echo=FALSE, results=hide}
\usepackage{amsfonts,rotating}

\title{Choosing Color Palettes for Statistical Graphics}
\author{Achim Zeileis \textnormal{and} Kurt Hornik\\Wirtschaftsuniversit\"at Wien, Austria}
\Plainauthor{Achim Zeileis, Kurt Hornik}
\Keywords{qualitative palette, sequential palette, diverging palette, HCL colors, HSV colors, perceptually-based color space}

\Abstract{
  Statistical graphics are often augmented by the use of color
  coding information contained in some variable. When this involves
  the shading of areas (and not only points or lines)---e.g., as in bar plots, pie charts,
  mosaic displays or heatmaps---it is important that the colors are perceptually based
  and do not introduce optical illusions or systematic bias. Here, we discuss
  how the perceptually-based Hue-Chroma-Luminance (HCL) color space can be used for deriving suitable
  color palettes for coding categorical data (qualitative palettes) and numerical
  variables (sequential and diverging palettes).
}

\begin{document}

<<preliminaries>>=
library("vcd")
library("mvtnorm")
library("KernSmooth")

source("functions.R")
source("Nigeria/bnd.R")

generate_png <- TRUE
@

\section{Introduction} \label{sec:intro}

Color is an integral element of graphical displays in general, and many statistical
graphics in particular. Statistical software packages typically provide various color
palettes and allow practitioners to employ these for visualizing data in various types
of displays. However, more often than not, there is relatively little guidance about
how to choose a suitable palette for a certain visualization task. Consequently,
sub-optimal color palettes are used for too many color graphics displayed in journal articles
or on presentation slides which could easily be enhanced if the underlying information
were captured appropriately in the color schemes. Here, we address
this problem by suggesting a color selection strategy for visualizing both categorical
and numerical information by selecting colors along axes in a color space whose axes
can be matched with perceptual axes of the human visual system.

For implementing color palettes in computer programs, typically color spaces are
employed that provide a mapping to Red-Green-Blue (RGB) colors. RGB is an additive
color model which is used for generating colors on computer screens
\citep[by mixing different amounts of the primary colors red, green and blue,
see][for more details]{vcd:Poynton:2000}. While being eminently useful for generating
colors on computer screens, it is hard for humans to select the coordinates in RGB
space corresponding to a certain color. Therefore, color picker tools in computer
programs are based on different color models---starting from the pioneering introduction
of Hue-Saturation-Value (HSV) colors \citep{vcd:Smith:1978}---which try to capture the
dimensions of human visual perception. HSV space is a simple transformation of RGB
space which is also implemented in many statistical software packages
\citep[see][for more details on HSV colors and links to further information about the other color
spaces discussed in the following]{vcd:Wiki+HSV:2006}. Although being easy to use,
HSV space exhibits a number of disadvantages: It is relatively difficult to select sets of
HSV coordinates that yield colors that are ``in harmony'' \citep[see][]{vcd:Munsell:1905}.
The reason for this is that colors with different hues also differ in saturation and brightness.
For statistical graphics, this is important because it can introduce size distortions in
the perception of shaded areas and color-caused optical illusions \citep{vcd:Cleveland+McGill:1983}.
Furthermore, the use of HSV colors encourages the use of flashy and highly saturated
colors which are good for drawing attention to a plot but hard to look at for a longer time.

Despite these known drawbacks, HSV space is still the predominantly-used color model in
color picker tools \citep{vcd:Moretti+Lyons:2002,vcd:Meier+Spalter+Karelitz:2004}
and the basis for many palettes in statistical software packages. A notable
exception is \pkg{ColorBrewer.org} \citep{vcd:Harrower+Brewer:2003},
an online tool for selecting color schemes for maps. It provides a rich
collection of prefabricated palettes (with a fixed maximal number
of colors) and guides its users how to choose a suitable palette for coding
various types of information. Here, we take a similar approach
and describe strategies for the choice of color palettes for categorical and numerical
data. Following \cite{vcd:Brewer:1999} and \cite{vcd:Harrower+Brewer:2003}, we distinguish
three types of palettes: qualitative, sequential and diverging. The first is tailored
for coding categorical information and the latter two are aimed at numerical variables
(or ordinal variables if some numerical coding for its levels is used).
Unlike \pkg{ColorBrewer.org}, we do not only provide fixed sets of colors but suggest
a general principle for selecting colors by traversing paths along perceptual axes in
a suitable color space. Consequently, the user can decide which path exactly should be
taken and how many colors should be selected. The color space employed by us is the
Hue-Chroma-Luminance (HCL) color space \citep[see][]{vcd:Ihaka:2003} and we show how
the general principles suggested can be turned into formulas describing paths of
coordinates in this space. Given a mapping from HCL to RGB coordinates, our formulas are
extremely easy to implement in software and we provide such an implementation
in the \proglang{R} language \citep{vcd:R:2006} using the powerful \proglang{R} graphics
system \citep[see][]{vcd:Murrell:2006} and the HCL
color implementation from package \pkg{colorspace} \citep{vcd:Ihaka:2006}. This gives the user
both a conceptual and computational tool box for experimenting with color palettes for
a particular display.

The remainder of the paper is organized as follows: Section~\ref{sec:motivation} provides
several motivating examples, showing how typical HSV-based graphics can be enhanced
by using HCL-based palettes. Section~\ref{sec:spaces} gives a brief introduction
to the underlying HSV and HCL color spaces before Section~\ref{sec:palettes} 
suggests strategies for deriving HCL-based qualitative, sequential, and diverging palettes.
Section~\ref{sec:software} offers some general remarks on the implementation in statistical
software packages as well as some details on our implementation in \proglang{R}.
Section~\ref{sec:discussion} concludes the paper with a discussion.


\section{Motivation} \label{sec:motivation}

To show what can be gained by selecting appropriate color schemes, we present a collection
of illustrations with typical color graphics based on HSV palettes (always in the left panels)
and more suitable HCL palettes (always in the right panels). All HSV color palettes (and some
of the data sets) are taken from recent publications in statistical journals such as
\textit{Journal of the American Statistical Association},
\textit{Journal of Computational and Graphical Statistics} or
\textit{Computational Statistics \& Data Analysis}. The examples have been selected to provide
an overview of typically colored statistical graphics and their respective pitfalls (concerning
color palette choice).
%% All graphics are in principle very useful but can be even enhanced
%% by using better color schemes.

Our first illustration is a heatmap, a very popular display for visualizing a scalar function of
two arguments. Here, we use a bivariate kernel density estimate \citep[for the Old
Faithful geyser eruptions data from][]{vcd:Azzalini+Bowman:1990}---other typical applications
include objective functions with two arguments \citep[as in][]{vcd:Gneiting+Sevcikova+Percival:2006}
or (physical) measurements on a 2-dimensional grid \citep[as in][]{vcd:Yang+Buckley+Dudoit:2002}.
Figure~\ref{fig:bkde} shows such a heatmap bringing out the relationship between the duration
of an eruption of the Old Faithful geyser in Yellowstone National Park 
and the waiting time for this eruption. It reveals a multi-modal distribution: short waiting
times (around 50 minutes) are typically followed by a long eruption (around 4 minutes)
whereas long waiting times (around 80 minutes) can be followed by either a long
or short eruption (around 4 minutes). 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<bkde>>=
if(generate_png) {
  data("geyser", package = "MASS")
  ## geyser2 <- cbind(geyser$duration[-299], geyser$waiting[-1])
  geyser2 <- cbind(geyser$duration, geyser$waiting)
  dens <- bkde2D(geyser2, bandwidth = c(0.2, 3), gridsize = c(201, 201))
  plot_bkde2D <- function(x, col = NULL, xlab = "duration", ylab = "waiting time", legend = FALSE, ...) {
    if(is.null(col)) col <- rev(grey.colors(33))
    if(legend) {
      filled.contour(x$x1, x$x2, x$fhat, col = col, nlevels = length(col), xlab = xlab, ylab = ylab, ...)
    } else {
      image(x$x1, x$x2, x$fhat,
        breaks = seq(from = min(x$fhat), to = max(x$fhat), length.out = length(col) + 1),
        xlab = xlab, ylab = ylab, col = col, axes = FALSE, cex.lab = 1.5, ...)
      box()
      axis(1, cex.axis = 1.5)
      axis(2, cex.axis = 1.5)
    }
    invisible(x)
  }

  png(file = "bkde.png", height = 810, width = 840)
  par(mfrow = c(2, 2))
  plot_bkde2D(dens, col = hsv(seq(from = 2/3, to = 0, length = 33), 0.8, 0.9))
  ## plot_bkde2D(dens, col = rainbow(33, start = 1/3, end = 1, v = 0.8, s = 0.9))
  plot_bkde2D(dens, col = rev(sequential_hcl(33, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  plot_bkde2D(dens, col = rev(heat.colors(33)))
  plot_bkde2D(dens, col = rev(heat_hcl(33, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  dev.off()
}
@
\includegraphics{bkde}
\setkeys{Gin}{width=.47\textwidth}
<<bkde-pal>>=
if(generate_png) {
  png(file = "bkde-pal.png", height = 160, width = 396)
  par(mfrow = c(4, 1), mar = c(0, 0, 0, 0), oma = c(2, 1.5, 0, 1.5))
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    hsv(seq(from = 2/3, to = 0, length = 99), 0.8, 0.9))
    ## rainbow(99, start = 1/3, end = 1, v = 0.8, s = 0.9))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat.colors(99)))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat_hcl(99, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(sequential_hcl(99, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  box()
  axis(1, cex.axis = 1.5)
  dev.off()
}
@
\includegraphics{bkde-pal}
\caption{\label{fig:bkde} Bivariate density estimation for Old Faithful geyser eruptions.}
\end{center}
\end{figure}

A simple and very effective palette for such a display is a set of gray colors
as in the top right panel of Figure~\ref{fig:bkde}. This is often (appropriately) used
in printed papers when the journal does not offer color graphics---however, in journals
that support color graphics (or on presentation slides and in interactive usage in statistical
software packages), many users prefer to have colored displays and most often use HSV
palettes (as in the two left two panels). These palettes code the variable of interest
by varying hue in an HSV color wheel as done by \citet[Figure~4a]{vcd:Yang+Buckley+Dudoit:2002}
or \citet[Figures~1--4]{vcd:Gneiting+Sevcikova+Percival:2006}. The palette in the upper left panel
codes increasing density by going from a blue to a red hue (via green and yellow)---a similar
strategy are the ``heat colors'' in the lower left panel that increase from yellow to red.
The latter works a bit better than the former, however both palettes exhibit several drawbacks.
The modes in the map look much more like ``rings'' rather than a smoothly increasing/decreasing 
density. The heatmap looks very flashy which---although good for drawing attention to a plot---makes
it hard to hold the attention of the viewer for a longer time because the large areas shaded
with saturated colors can be distracting and produce after-image effects \citep{vcd:Ihaka:2003}.

In contrast, the gray colors used in the top right panel do not exhibit the same disadvantages,
coding the variable of interest much better and without flashy colors. If, however, the user wants
to add some color to the plot, this could be done by using a better balanced version of the heat
colors (as shown in the bottom right panel). These colors also increase from a yellow to a red
hue while being balanced towards the same gray as in the grayscale palette (i.e., when converted
to a grayscale or printed out on a grayscale printer, the upper and lower right panel would 
essentially look identical). Both palettes have in common that they give increasing perceptual emphasis
to regions with increasing density, resulting in a heatmap that highlights the (small)
interesting high-density regions and not to the large low-density regions surrounding them.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<nigeria>>=
if(generate_png) {
  m <- read.bnd("Nigeria/nigeria37.bnd")
  fit <- read.table("Nigeria/reml_purespatial_f_district_spatial.res", header = TRUE)
  fit <- fit[order(fit$district),]

  png(file = "nigeria.png", height = 400, width = 840)
  par(mfrow = c(1, 2), mar = c(2.22, 0.22, 1.02, 0.22))
  plot(m, z = fit$pmode, fill = rev(rainbow(99, start = 0, end = 1/3)),
    zlim = c(-0.65, 0.65), legend = FALSE)
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  dev.off()
}
@
\includegraphics{nigeria}
\setkeys{Gin}{width=.47\textwidth}
<<nigeria-pal>>=
if(generate_png) {
  png(file = "nigeria-pal.png", height = 80, width = 396)
  par(mfrow = c(2, 1), mar = c(0, 0, 0, 0), oma = c(2, 0.2, 0, 0.2))
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(rainbow(99, start = 0, end = 1/3)))
  box()
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  box()
  axis(1, cex = 1.5)
  dev.off()
}
@
\includegraphics{nigeria-pal}
\caption{\label{fig:nigeria} Posterior mode estimates for childhood mortality in Nigeria.}
\end{center}
\end{figure}

A similar example is presented in Figure~\ref{fig:nigeria}
\citep[taken from][Figure~5, left]{vcd:Kneib:2006}, depicting posterior mode estimates
for childhood mortality in different regions of Nigeria. Deviations from a model for
childhoold mortality are brought out by shading a map according to the corresponding
residuals, revealing decreased mortality in the south-west and increased mortality in
the north-east. \cite{vcd:Kneib:2006} uses an HSV-based palette coding the residuals by
the hue, going from green via yellow to red. Our HCL-based palette also employs green
and red hues for negative and postive residuals respectively, but codes neutral values
(around 0) by a neutral light gray. Compared to the HSV-based palette, this offers again
a number of advantages: only the interesting areas are highlighted by high-chroma colors;
flashy colors are avoided making it easier to look at the display for a longer time; positive
and negative residuals with the same absolute size receive the same perceptual weight
by being balanced towards the same gray.


\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<seats, fig=TRUE, height=4, width=11>>=
par(mar = rep(0.8, 4), mfrow = c(1, 2))
seats <- structure(c(226, 61, 54, 51, 222),
  .Names = c("CDU/CSU", "FDP",  "Linke", "Gruene", "SPD"))
parties_hcl <- rainbow_hcl(6, c = 60, l = 75)[c(5, 2, 6, 3, 1)]
parties_hsv <- hsv(c(0, 60, 300, 120, 0)/360, v = c(0, 1, 1, 1, 1))
names(parties_hcl) <- names(parties_hsv) <- names(seats)
names(seats)[4] <- "Grüne"
pie(seats, clockwise = TRUE, col = parties_hsv, radius = 1)
pie(seats, clockwise = TRUE, col = parties_hcl, radius = 1)
@
\caption{\label{fig:seats} Seats in the German parliament.}
\end{center}
\end{figure}


Although problematic for many tasks, pie charts can be useful for visualizing
whether a set of pie segments constitutes a majority. A typical application is shown
in Figure~\ref{fig:seats}, visualizing the distribution of seats in the German parliament
``Bundestag'' following the 2005 election. In this election, five parties were able to
obtain enough votes to enter the Bundestag---however, neither the governing
coalition of SPD and Gr\"une nor the opposition of CDU/CSU and FDP could assemble a majority.
Given that no party would enter a coalition with the leftists ``Die Linke'', this lead to
a big coalition of CDU/CSU and SPD. In graphical displays, the parties are usually matched
by using colors as metaphors: red for the social democrats SPD, black for the conservative
CDU/CSU, yellow for the liberal FDP, green for the green party ``Die Gr\"unen'' and purple 
for the leftist party ``Die Linke''. The left panel shows fully saturated HSV colors as usually
found in the (German) media whereas the right panel uses less flashy HCL colors with the
same hues (except for the CDU/CSU where a blue hue instead of the extreme ``color'' black
is used). The advantage of the latter is again that they are easier to hold in focus for
a longer time. Furthermore, they are all balanced towards the same gray and have the same
amount of color, resulting in a perceptually balanced palette that does not introduce undesired
graphical distractions. While it could be argued that this pie chart is such a simple
display that a well-balanced palette is not so important and that flashy colors are to
be preferred, the balancing properties of the HCL-based palette are very important in more
complex displays such as the mosaic display in Figure~\ref{fig:votes}. This re-uses the same
colors and shows the distribution of votes in the 2005 election
stratified by province (Bundesland). The order of provinces is from 
north to south, first for the 10 western provinces (the former Federal Republic of Germany, FRG),
then for the 6 eastern provinces (the former German Democratic Republic, GDR). 
Clearly, the SPD performed better in the north and the CDU/CSU better in the south; furthermore,
Die Linke performed particularly well in the eastern provinces and in Saarland.

\setkeys{Gin}{width=\textwidth}
\begin{sidewaysfigure}[p]
\begin{center}
<<votes, fig=TRUE, height=6, width=14>>=
data("Bundestag2005", package = "vcd")
votes <- Bundestag2005[c(1, 3:5, 9, 11, 13:16, 2, 6:8, 10, 12),
                       c("CDU/CSU", "FDP", "SPD", "Gruene", "Linke")]
parties_hcl <- parties_hcl[colnames(votes)]
parties_hsv <- parties_hsv[colnames(votes)]
dimnames(votes)[[1]][c(9, 16)] <- c("Baden-Württemberg", "Thüringen")
dimnames(votes)[[2]][c(4, 5)] <- c("Gr", "Li")

grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
mosaic(votes, gp = gpar(fill = parties_hsv),
  spacing = spacing_highlighting, labeling = labeling_left,
  labeling_args = list(rot_labels = c(0, 90, 0, 0), pos_labels = "center",
  just_labels = c("center","center","center","right"), varnames = FALSE),
  margins = unit(c(2.5, 1, 1, 12), "lines"),
  keep_aspect_ratio = FALSE, newpage = FALSE)
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row=1))
mosaic(votes, gp = gpar(fill = parties_hcl),
  spacing = spacing_highlighting, labeling = labeling_left,
  labeling_args = list(rot_labels = c(0, 90, 0, 0), pos_labels = "center",
  just_labels = c("center","center","center","right"), varnames = FALSE),
  margins = unit(c(2.5, 1, 1, 12), "lines"),
  keep_aspect_ratio = FALSE, newpage = FALSE)
popViewport(2)
@
\caption{\label{fig:votes} Votes in the German election 2005 (by province).}
\end{center}
\end{sidewaysfigure}

Color choice is usually much more important in graphical displays with
shaded areas compared to displays with only points or lines. However, color choice
becomes much more relevant also in scatter plots when there are many points. As an
example, Figure~\ref{fig:scatter} depicts a scatter plot with three clusters similar to 
the one shown in \citet[Figure~3]{vcd:Celeux+Hurn+Robert:2000}. To indicate cluster
membership, three different colors (green, yellow, red) are employed. The HSV colors in
the left panel are again very flashy and differ strongly with respect to luminance: the
yellow is much lighter and hardly visible. In contrast, the HCL colors in the right
panel use the same hues, but are balanced with respect to chroma and luminance, i.e.,
the amount of color and gray.

As our final example, Figure~\ref{fig:haireye} \citep[taken from][Figure~11, left/middle]{vcd:Friendly:2002}
visualizes the cross-tabulation of hair end eye color of 592 students in a mosaic display.
Clearly, hair and eye color are not independent and the pattern of association is highlighted
by means of residual-based shading. Cells associated with Pearson residuals whose absolute value exceeds
(2 or) 4 are shaded (light) blue/red. This shows that there are significantly more students
with black hair and brown eyes, blond hair and blue eyes, red hair and green eyes than expected
under independence. Conversely, fewer students than expected have blond hair and brown/hazel eyes
or black hair and blue eyes. Comparing the HSV and HCL colors in Figure~\ref{fig:haireye},
it is shown again that the HCL colors are better balanced (between the red and blue colors)
and less flashy. Even the cells associated with small residuals (below 2) are a bit easier
to read when shaded in a light grey rather than white. More details and extensions to residual-based
shadings can be found in \cite{vcd:Zeileis+Meyer+Hornik:2007}.


\setkeys{Gin}{width=\textwidth}
\begin{figure}[h!]
\begin{center}
<<scatter>>=
if(generate_png) {
  set.seed(123)
  vc <- function(var1, var2, cov)
    matrix(c(var1, cov * sqrt(var1 * var2), cov * sqrt(var1 * var2), var2), ncol = 2)
  dat <- rbind(rmvnorm(1000, c(0, 0), vc(0.05, 0.3, -0.95)),
               rmvnorm(1000, c(1.8, 2.5), vc(0.12, 0.25, 0)),
               rmvnorm(1000, c(3.8, 3.5), vc(0.02, 0.15, -0.8)))
  dat <- data.frame(y = dat[,2], x = dat[,1], id = rep(1:3, rep(1000, 3)))

  png(file = "scatter.png", height = 350, width = 840)
  par(mfrow = c(1, 2), mar = rep(0.5, 4))
  plot(y ~ x, data = dat, axes = FALSE, xlab = "", ylab = "", pch = c(3, 22, 1)[id],
    col = hsv(c(1/3, 1/6, 0))[id])
  box()
  plot(y ~ x, data = dat, axes = FALSE, xlab = "", ylab = "", pch = c(3, 22, 1)[id],
    col = hcl2hex(c(120, 60, 0), 70, 65, fix = FALSE)[id])
  box()
  dev.off()
}
@
\includegraphics{scatter}
\caption{\label{fig:scatter} Scatter plot with three clusters.}
\end{center}
\end{figure}


\setkeys{Gin}{width=\textwidth}
\begin{figure}[h!]
\begin{center}
<<haireye, fig=TRUE, height=5.5, width=12>>=
he <- margin.table(HairEyeColor, 1:2)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
mosaic(he, gp = shading_hsv, split_vertical = TRUE, newpage = FALSE, legend = FALSE)
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row=1))
mosaic(he, gp = shading_hcl, split_vertical = TRUE, newpage = FALSE, legend = FALSE)
popViewport(2)
@
\caption{\label{fig:haireye} Extended mosaic display for hair and eye color data.}
\end{center}
\end{figure}

\section{Color spaces} \label{sec:spaces}

For choosing color palettes it is helpful to have an idea how
human color vision evolved. It has been hypothesized that it developed in three
distinct stages: 1.~perception of \emph{light/dark} contrasts (monochrome only),
2.~\emph{yellow/blue} contrasts (usually associated with our notion of warm/cold colors),
3.~\emph{green/red} contrasts (helpful for assessing the ripeness of fruit). See 
\cite{vcd:Ihaka:2003} for more details and references.

Due to these three color axes, colors are typically described as
locations in 3-dimensional spaces. However, human perception of color
does not correspond to the physiological axes above, but rather to polar
coordinates in the color plane (yellow/blue vs.~green/red) plus a third
light/dark axis. Thus, perceptually-based color spaces try to capture the
perceptual axes
\begin{itemize}
  \item \emph{hue} (dominant wavelength)
  \item \emph{chroma} (colorfulness, intensity of color as compared to gray)
  \item \emph{luminance} (brightness, amount of gray)
\end{itemize}

A popular implementation of such a color space, available in many graphics and
statistics software packages, are HSV colors. They are a simple transformation of RGB colors
and are defined by a triplet $(H, S, V)$ with $H \in [0, 360]$ and $S, V \in [0, 100]$.
%% HSV space has the shape of a single regular cone (often inflated to a regular
%% cylinder). Vertical sections through this space are shown in the upper panel
%% of Figure~\ref{fig:hsv-hcl}, depicting hue and saturation given different value levels.
Although simple to specify and easily available in many computing environments,
HSV colors have a fundamental drawback: its three dimensions map to the three
dimensions of human color perception very poorly. The three dimensions are
confounded:
%% which is most easily seen when converting the vertical sections to 
%% gray scale images in Figure~\ref{fig:hsv-hcl-gray}. Clearly,
The brightness of
colors is not uniform over hues and saturations (given value)---therefore,
HSV colors are often not considered to be perceptually based.

To overcome these drawbacks, various color spaces have been suggested
that properly map to the perception dimensions, the most prominent of which are
the CIELUV and CIELAB spaces developed by the \cite{vcd:CIE:2004}. \cite{vcd:Ihaka:2003}
argues that CIELUV colors are typically preferred for use with emissive technologies
such as computer screens which makes them an obvious candidate for implementation
in statistical software packages. By taking polar coordinates in the UV plane of
CIELUV, HCL colors are obtained, defined by
a triplet $(H, C, L)$ with $H \in [0, 360]$ and $C, L \in [0, 100]$.
%% HCL space has the shape of a distorted double cone: the admissible combinations of
%% chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
%% The lower panel of Figure~\ref{fig:hsv-hcl} shows
%% vertical sections through this space: each of the resulting hue/chroma planes (given
%% luminance) is now properly balanced towards the same gray (going from black to white
%% with increasing luminance) which becomes obvious when converting the colors to
%% a gray scale as in Figure~\ref{fig:hsv-hcl-gray}. 
Given a certain luminance $L$, all colors resulting from different combinations
of hue $H$ and chroma $C$ are balanced towards the same gray (and look the same
when converted to a gray scale). However, the admissible combinations of
chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
The reason for this is that some hues lead to light and others to dark colors,
e.g., full chroma yellow is brighter (i.e., has higher luminance) than full chroma blue.

The balancing of HCL colors
gives us the opportunity to conveniently choose color palettes which code categorical
and/or numerical information by translating it to paths along the three perceptual axes.
However, some care is required for dealing with the irregular shape of the HCL space
which will be addressed in the following sections.


\section{Color palettes} \label{sec:palettes}

\subsection{Qualitative palettes} \label{sec:qualitative}

\setkeys{Gin}{width=\textwidth}
\begin{figure}[b!]
\begin{center}
<<wheel, fig=TRUE, height=4, width=11>>=
par(mar = rep(0.8, 4), mfrow = c(1, 2))
par(mfrow = c(1,2), mar = c(1,1,1,1), oma = c(0,0,0,0))
pie(rep(1,6), radius = 1, col = rainbow(6), labels = 360 * 0:5/6)
pie(rep(1,6), radius = 1, col = rainbow_hcl(6, c = 50, l = 70), labels = 360 * 0:5/6)
@
\caption{\label{fig:wheel} HSV-based and HCL-based color wheel.}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-construct>>=
if(generate_png) {
  png(file = "pal-q-construct.png", height = 480, width = 480)
  hcl.wheel(luminance = 70, do.label = FALSE, inner.circle = TRUE)
  rect(0.45, -0.05, 0.55, 0.05, col = hcl2hex(0, 50, 70))
  rect(-cos(pi/3)/2-0.05, sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, sin(pi/3)/2+0.05, col = hcl2hex(120, 50, 70))
  rect(-cos(pi/3)/2-0.05, -sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, -sin(pi/3)/2+0.05, col = hcl2hex(240, 50, 70))
  dev.off()
}
@
\includegraphics{pal-q-construct}
\vspace*{-2cm}
\caption{\label{fig:pal-q-construct} Constructing qualitative palettes. In the hue/chroma
plane for $L = 70$, the dashed circle correponds to a radius $C = 50$ with chosen angles
$H = 0, 120, 240$.}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(2, 2), mar = c(0, 0, 3, 2))
pal(rainbow_hcl(4, start = 30, end = 300), main = "dynamic [30, 300]")
pal(rainbow_hcl(4, start = 60, end = 240), main = "harmonic [60, 240]")
pal(rainbow_hcl(4, start = 270, end = 150), main = "cold [270, 150]")
pal(rainbow_hcl(4, start = 90, end = -30), main = "warm [90, -30]")
@
\caption{\label{fig:pal-q-examples} Examples for qualitative palettes. Hue is varied
in different intervals for given $C = 50$ and $L = 70$.}
\end{center}
\end{figure}

Qualitative palettes are sets of colors for depicting different categories,
i.e., for coding a categorical variable. Usually, these should give the same
perceptual weight to each category so that no group is perceived to be larger or more
important than any other one. Typical applications of qualitative palettes in
statistics would be bar plots \citep[see][]{vcd:Ihaka:2003}, pie charts (see Figure~\ref{fig:seats}) 
or highlighted mosaic displays (see Figure~\ref{fig:votes}).

\cite{vcd:Ihaka:2003} describes a simple strategy for choosing such palettes: chroma
and luminance are kept fixed and only the hue is varied for obtaining different colors
which are consequently all balanced towards the same gray. This effect is illustrated
in Figure~\ref{fig:wheel} which shows a color wheel obtained by varying the hue only in
HSV coordinates $(H, 100, 100)$ and HCL coordinates $(H, 50, 70)$. Clearly, not only the
hue but also the amount of chroma and luminance varies for the HSV wheel.

Figure~\ref{fig:pal-q-construct} depicts how the HCL-based color wheel is constructed.
It shows the hue/chroma plane of HCL space given a luminance of $L = 70$. Not all
combinations of hue and chroma are admissible, however for a chroma of $C = 50$ a full
color wheel can be obtained.
For choosing the hues in a certain palette, various strategies are conceivable.
A simple and intuitive one is to use colors as metaphors for categories
(e.g., for political parties as in Figures~\ref{fig:seats} and \ref{fig:votes}),
another approach would be to use segments from
the color wheel corresponding to nearby or distant colors. The latter is shown
in Figure~\ref{fig:pal-q-examples} which depicts
examples for generating qualitative sets of colors $(H, 50, 70)$.
In the upper left panel colors from the full spectrum are used ($H = 30, 120, 210, 300$)
creating a `dynamic' set of colors. The upper right panel shows a `harmonic'
set with $H = 60, 120, 180, 240$. Warm colors (from the blue/green part of the spectrum: 
$H = 270, 230, 190, 150$) and cold colors (from the yellow/red part of the spectrum:
$H = 90, 50, 10, 330$) are shown in the lower left and right panel, respectively.


\subsection{Sequential palettes} \label{sec:sequential}

Sequential palettes are used for coding numerical information that ranges
in a certain interval where low values are considered to be uninteresting and
high values are interesting. Suppose we need to visualize an intensity or
interestingness $i$ which (without loss of generality) is scaled to the unit
interval. A typical application in statistics are heatmaps (see Figure~\ref{fig:bkde}).

The simplest solution to this task is to employ light/dark contrasts, i.e., rely
on the most basic perceptual axis. The interestingness can be coded
by an increasing amount of gray corresponding to decreasing luminance in HCL space:
  \[ (H, 0, 90 - i \cdot 60), \]
where the hue $H$ used does not matter, chroma is set to 0 (i.e., no color), and 
luminance ranges in $[30, 90]$ avoiding the extreme colors white ($L = 100$) and 
black ($L = 0$). Instead of going linearly from light to dark gray, luminance
could also be increased nonlinearly, e.g., by some function $i' = f(i)$ that
controls whether luminance is increased quickly with intensity or not. We found $i' = f(i) = i^p$ 
to be a convenient transformation where the power $p$ can be varied to achieve
different degrees of non-linearity.

Furthermore, the intensity $i$ could additionally be coded by colorfulness (chroma), e.g.,
  \[ (H, 0 + i' \cdot C_{\max}, L_{\max} - i' \cdot (L_{\max} - L_{\min})). \]
This strategy is depicted in the left panel of Figure~\ref{fig:pal-s-construct} for a blue
hue $H = 260$ and different combinations of maximal chroma ($C_{\max} = 0$, $80$ and $100$,
respecitvely) and minimal luminance ($L_{\min} = 30$, $30$ and $50$, respectively).
The first two combinations are also shown in the first two rows of Figure~\ref{fig:pal-s-examples}.
The right panel of Figure~\ref{fig:pal-s-construct} shows that the exact same strategy
is not possible  for the green hue $H = 120$. While the gray colors without chroma can be chosen in 
the same way, there is a stronger trade-off between using dark colors (with low luminance)
and colorful colors (with high chroma). Hence, the second path from light gray to 
full green ends at a much lighter color with $L_{\min} = 75$. 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-construct>>=
if(generate_png) {
  png(file = "pal-s-construct.png", height = 420, width = 840)
  par(mfrow = c(1, 2))
  hue.slice(260, grid.n = 301)
  lines(c(0, 100), c(90, 50), lty = 2)
  lines(c(0, 80), c(90, 30), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 67.5, 52.5, 72.5, col = hcl2hex(260, 50, 70))
  rect(95, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  rect(37.5, 57.5, 42.5, 62.5, col = hcl2hex(260, 40, 60))
  rect(77.5, 27.5, 82.5, 32.5, col = hcl2hex(260, 80, 30))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  hue.slice(120, grid.n = 301)
  lines(c(0, 100), c(90, 75), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 80, 52.5, 85, col = hcl2hex(120, 50, 82.5))
  rect(95, 72.5, 100, 77.5, col = hcl2hex(120, 100, 75))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  dev.off()
}
@
\includegraphics{pal-s-construct}
\caption{\label{fig:pal-s-construct} Constructing sequential palettes. The chroma/luminance
plane is shown for two hues $H = 260$ (left) and $H = 120$ (right). Colors are chosen by varying
either only luminance or both luminance and chroma.}
\end{center}
\end{figure}

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-examples, fig=TRUE, height=5, width=6>>=
par(mfrow = c(5, 1), mar = c(0.25, 0, 0.25, 0))
pal(sequential_hcl(12, c = 0, power = 2.2))
pal(sequential_hcl(12, power = 2.2))
pal(heat_hcl(12, c = c(80, 30), l = c(30, 90), power = c(1/5, 2)))
pal(terrain_hcl(12, c = c(65, 0), l = c(45, 90), power = c(1/2, 1.5)))
pal(rev(heat_hcl(12, h = c(0, -100), l = c(75, 40), c = c(40, 80), power = 1)))
@
\caption{\label{fig:pal-s-examples} Examples for sequential palettes, varying
only luminance (first panel), chroma and luminance (second panel), and hue,
chroma and luminance (remaining panels).}
\end{center}
\end{figure}

To increase the contrast between the colors in the palette even further, the ideas from
the previous sequential palettes can also be combined with qualitative palettes by
simultaneously varying the hue as well:
  \[ (H_2 - i \cdot (H_1 - H_2), C_{\max} - i' \cdot (C_{\max} - C_{\min}),
      L_{\max} - i'' \cdot (L_{\max} - L_{\min})). \]
One application is an HCL-based version of ``heat colors'' that increase from a light yellow
(e.g., $(90, 30, 90)$) to a full red (e.g., $(0, 100, 50)$). To make the change in hue
visible, the chroma needs to increase rather quickly for low values of $i$ and then only
slowly for higher values of $i$. This can be achieved by choosing an appropriate transformation
$i'$ for chroma and a different transformation $i''$ for the luminance.
Such a strategy is adopted for the palettes shown in the lower three rows in
Figure~\ref{fig:pal-s-examples} using different pairs of hues as well as different
chroma and luminance contrasts.


\subsection{Diverging palettes} \label{sec:diverging}

Diverging palettes are also used for coding numerical information ranging in a certain
interval---however, this interval includes a neutral value. Examples for this include
residuals or correlations (both with the neutral value 0) or binary classification
probabilities (with neutral value 0.5) that could be visualized in mosaic plots
(see Figure~\ref{fig:haireye}), classification maps or model-based shading in maps
such as Figure~\ref{fig:nigeria}. Analogously to the previous
section, we suppose that we want to visualize an intensity or interestingness $i$
from the interval $[-1, 1]$ (without loss of generality).

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-construct>>=
if(generate_png) {
  png(file = "pal-d-construct.png", height = 480, width = 534)
  hue260 <- hue.slice(260, grid.n = 301, plot = FALSE)
  hue360 <- hue.slice(360, grid.n = 301, plot = FALSE)
  mychroma <- as.numeric(colnames(hue260))
  luminance <- as.numeric(rownames(hue260))
  nc <- ncol(hue260)
  nl <- nrow(hue260)
  plot(0.5, 0.5, xlim = c(-100, 100), ylim = c(0, 100), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
  for(i in 1:(nc-1)) {
    rect(mychroma[i], luminance[-nl], mychroma[i] + 100/(nc-1), luminance[-1], border = hue260[,i+1], col = hue260[,i+1])
  }
  for(i in 1:(nc-1)) {
    rect(-mychroma[i], luminance[-nl], -(mychroma[i] + 100/(nc-1)), luminance[-1], border = hue360[,i+1], col = hue360[,i+1])
  }
  axis(1, labels = FALSE, at = c(-100, 0, 100))
  axis(2, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  axis(3, at = -4:4*25, labels=c(4:0*25, 1:4*25))
  axis(4, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  mtext(c("hue = 0", "hue = 260"), side = 3, at = c(-50, 50), line = 3, cex = 1.2)
  mtext("chroma", side = 3, at = 0, line = 2)
  mtext("luminance", side = 2, at = 50, line = 2)
  mtext("luminance", side = 4, at = 50, line = 2)
  lines(c(-100, 0, 100), c(50, 90, 50), lty = 2)
  rect(-100, 47.5, -90, 52.5, col = hcl2hex(0, 100, 50))
  rect(-55, 67.5, -45, 72.5, col = hcl2hex(0, 50, 70))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(45, 67.5, 55, 72.5, col = hcl2hex(260, 50, 70))
  rect(90, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  lines(c(-80, 0, 80), c(30, 90, 30), lty = 2)
  rect(-85, 27.5, -75, 32.5, col = hcl2hex(0, 80, 30))
  rect(-45, 57.5, -35, 62.5, col = hcl2hex(0, 40, 60))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(35, 57.5, 45, 62.5, col = hcl2hex(260, 40, 60))
  rect(75, 27.5, 85, 32.5, col = hcl2hex(260, 80, 30))
  dev.off()
}
@
\includegraphics{pal-d-construct}
\caption{\label{fig:pal-d-construct} Constructing diverging palettes. The chroma/luminance
plane is shown back to back hues $H = 0$ and $H = 260$. Colors are chosen by simultaneously 
varying luminance and chroma.}
\end{center}
\end{figure}


\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(4, 1), mar = c(0.25, 0, 0.25, 0))
pal(diverge_hcl(7))
pal(diverge_hcl(7, c = 100, l = c(50, 90), power = 1))
pal(diverge_hcl(7, h = c(130, 43), c = 100, l = c(70, 90)))
pal(diverge_hcl(7, h = c(180, 330), c = 59, l = c(75, 95)))
@
\caption{\label{fig:pal-d-examples} Examples for diverging palettes with different
pairs of hues and decreasing luminance contrasts.}
\end{center}
\end{figure}

Given useful sequential palettes, deriving diverging palettes is easy: two different hues are
chosen for adding color to the same amount of `gray' at a given intensity $|i|$.
Figure~\ref{fig:pal-d-construct} shows the chroma/luminance plane back to back for the
hues $H = 0$ and 260 with two different paths---giving slightly different emphasis on
luminance or chroma contrasts---from a full red over a neutral grey to a full blue.
As Figure~\ref{fig:pal-s-construct} illustrates, the pair of hues should be chosen carefully
because the admissible values in the chrome/luminance plane differ across hues.
Clearly, for deriving symmetric palettes, only colors from the intersection of the
admissible chroma/luminance planes can be used. The particular hues $H = 0$ and $260$
used in Figure~\ref{fig:pal-d-construct} were chosen because they correspond to similar
geometric shapes in the chroma/luminance plane, allowing for both large chroma and
luminance contrasts. 
If potential viewers of the resulting graphic might be color-blind,
the pair of hues should be taken from the yellow/blue axis of the color wheel
rather than the green/red axis as contrasts on the latter axis are more difficult to 
distinguish for color-blind people \citep{vcd:Lumley:2006}.

Figure~\ref{fig:pal-d-examples} shows various examples of conceivable combinations of
hue, chroma and luminance. The first palette uses a broader range on the luminance axis
whereas the others mostly rely on chroma contrasts.


\section{Software} \label{sec:software}

Implementing the different color palettes suggested in the previous section 
is extremely easy if the software environment chosen already provides an implementation
of HCL colors: from the formulas provided above the HCL coordinates for a
palette can be conveniently computed. A bit more work is required if the software
package does not yet provide an HCL implementation. In that case, additional
functionality is needed for translating HCL coordinates to the software package's 
color system which may vary between different packages, but standardized RGB (sRGB)
is often used. The typical way of coordinate conversion is to go first from HCL to
CIELUV by simply transforming the polar $H$ and $C$ coordinates back to the original
$U$ and $V$. Subsequently, CIELUV is converted to CIEXYZ which in turn is converted
to sRGB (with the latter conversion depending on the device used for display).
The details of these conversions are somewhat technical and tedious (and hence
omitted here), however the conversion formulas are still straightfoward to
implement and can, for example, be found in \cite{vcd:Wiki+LUV:2006} or
\cite{vcd:Poynton:2000}.

The \proglang{R} system for statistical computing \citep{vcd:R:2006} already comes
with an open-source implementation of HCL (and other color spaces) in the package
\pkg{colorspace} \citep{vcd:Ihaka:2006}. The coordinate transformations mentioned
above are contained in \proglang{C} code within \pkg{colorspace} that are easy to
port to other statistical software systems. Based on \pkg{colorspace}, 
the package \pkg{vcd} \citep{vcd:Meyer+Zeileis+Hornik:2006} provides implementations
of all palettes discussed above. Qualitative palettes are provided by
\code{rainbow_hcl()} (named after the HSV-based function \code{rainbow()} in base
\proglang{R}). Sequential palettes based on a single hue are implemented in the function
\code{sequential_hcl()} while \code{heat_hcl()} offers sequential palettes based on
a range of hues. Diverging palettes can be obtained by \code{diverge_hcl()}.
Technical documentation along with a large collection of examples is available via
\verb/help("rainbow_hcl")/. \proglang{R} code for reproducing
Figures~\ref{fig:pal-q-examples}, \ref{fig:pal-s-examples} and \ref{fig:pal-d-examples}
(and some illustrations) can be accessed via \code{vignette("hcl-colors", package = "vcd")}.


\section{Discussion} \label{sec:discussion}

Many statistical graphics---especially when displayed on a computer screen,
e.g., as in interactive usage, electronic papers or presentation slides---employ
colors to code information about a certain variable. Despite this
omnipresence of color, there is often only little guidance in statistical
software packages on how to choose a palette appropriate for a particular
visualization task---auspicious tools such as \pkg{ColorBrewer.org} notwithstanding.
We try to address this problem by suggesting color schemes for coding
categorical information (qualitative palettes) and numerical information
(sequential and diverging palettes) based on the perceptually-based
HCL color space.

We provide paths through HCL space along perceptual axes
so that colors selected along these paths match perceptual dimensions.
This gives the users the possibility to conveniently experiment with the HCL-based
palettes by varying several graphical parameters. For qualitative
palettes, these are the coordinates on the chroma and luminance axis, respectively,
controlling whether the colors are light or dark and how colorful they are.
For sequential and diverging palettes, the user can decide whether contrasts
in the chroma or luminance direction (or both) should be employed. In our
experience (as illustrated in Section~\ref{sec:motivation}), chroma contrasts
work sufficiently well if a small set of colors is used. However, when a larger
set of colors is used (e.g., for heatmaps where extreme values should be identifiable)
it is much more important to have a big difference in luminance.
%% Another parameter in these 
%% palettes is the rate at which the intensity $|i|$ is increased from $0$ to $1$:
%% Employing a function $|i|^p$ for this, small
%% powers $p$ can be used if palettes with a lot of color should be 
%% constructed (e.g., to clearly separate regions in a classification map). On
%% the other hand, large powers $p$ will result in palettes with less color
%% (e.g., appropriate to highlight only extreme regions firmly classified in such a map).

Based on these conceputal guidelines and the computational tools readily
provided in the \proglang{R} system for statistical computing (and easily implemented in other
statistical software packages), users can generate palettes varying these
graphical parameters and thus adapting the colors to their particular graphical display.


\section*{Acknowledgements}

We are thankful to David Meyer, Paul Murrell, Brian~D.~Ripley,
Thomas Kneib, and Michael H\"ohle for feedback, suggestions and discussions.

\bibliography{vcd}

\end{document}

<<barplot, eval=FALSE>>=
x <- rbind(
c(255, 255, 111),
c(255, 255,  47),
c(120,  50,   1),
c(102, 204, 102),
c( 50, 204, 204),
c(203, 153, 204),
c(102, 204, 102),
c(255,  47,  47),
c(102, 204, 102))/255

y <- c(10, 20, 25, 18, 16, 13, 21, 15, 18) - 3

par(mfrow = c(1, 2))
barplot(y, col = hex(RGB(x[,1], x[,2], x[,3])), space = 0)
## barplot(y, col = hcl(attr(as(RGB(x[,1], x[,2], x[,3]), "polarLUV"), "coords")[,"H"],
##  c = 40, l = 80), space = 0)
barplot(y, col = rainbow_hcl(7, c = 40, l = 80)[c(3, 5, 2, 4, 6, 1, 4, 7, 4)], space = 0)
@
