\documentclass[10pt,a4paper]{article}

%% Packages:
\usepackage{graphicx,color,a4wide,thumbpdf,hyperref}

%% \usepackage{Sweave} is essentially
\RequirePackage[T1]{fontenc}
\RequirePackage{ae,fancyvrb}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontshape=sl}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontshape=sl}
\newenvironment{Schunk}{}{}

%% BibTeX
\usepackage[authoryear,round,longnamesfirst]{natbib}
\bibliographystyle{asa}
\bibpunct{(}{)}{;}{a}{}{,}

%% new commands
\let\code=\texttt
\let\proglang=\textsf
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\given}{\, | \,}

%% Colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{hellgrau}{rgb}{0.55,0.55,0.55}

%% mimic JCGS style
\renewcommand{\section}{\secdef \mysec \mysecnn}
\newcommand{\mysec}[2][default]{\vspace{1.3\baselineskip}%
  \pdfbookmark[1]{#1}{Section.\thesection.#1}%
  \refstepcounter{section}%
  {\begin{center} \large \bf \thesection. \uppercase{#1} \end{center}}%
  \vspace{0.7\baselineskip}}
\newcommand{\mysecnn}[1]{\vspace{1.3\baselineskip}%
  {\begin{center}\large \bf \uppercase{#1} \end{center}}%
  \vspace{0.7\baselineskip}}

\renewcommand{\subsection}{\secdef \mysubsec \mysubsecnn}
\newcommand{\mysubsec}[2][default]{\vspace{1.2\baselineskip}%
  \pdfbookmark[2]{#1}{Subsection.\thesubsection.#1}%
  \refstepcounter{subsection}%
  \noindent%
  {\large \textbf{\thesubsection{} {\sc#1}}} \vspace{.7\baselineskip}}
\newcommand{\mysubsecnn}[1]{\vspace{1.2\baselineskip}%
  \noindent%
  {\large \textbf{{\sc #1}}} \vspace{.7\baselineskip}}
\renewcommand{\abstractname}{}
\renewcommand{\refname}{REFERENCES}

%% Hyperref
\hypersetup{%
  pdftitle = {Visualizing (Conditional) Independence Using Extended Association and Mosaic Plots},
  pdfsubject = {Visualizing (Conditional) Independence},
  pdfkeywords = {contingency tables, association plots, mosaic plots, conditional
    inference, permutation tests},
  pdfauthor = {Achim Zeileis, David Meyer, Kurt Hornik},
  %% change colorlinks to false for pretty printing
  colorlinks = {true},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  hyperindex = {true},
  linktocpage = {true},
}


\begin{document}

\begin{center}
\textbf{\LARGE Visualizing (Conditional) Independence Using Extended Association and Mosaic Plots}

\vspace{0.5cm}
{\large Achim \textsc{Zeileis}, David \textsc{Meyer}, and Kurt \textsc{Hornik}}

\vspace{0.3cm}
\textit{\large Wirtschaftsuniversit\"at Wien, Augasse 2--6, 1090 Wien, Austria}\\[0.14cm]
{\large \textit{E-mail:} \texttt{Firstname.Lastname@wu-wien.ac.at}}
\end{center}

\SweaveOpts{engine=R,eps=FALSE}
\setkeys{Gin}{width=0.8\textwidth}

<<preliminaries,echo=FALSE,results=hide>>=
set.seed(12345)
library(vcd)

data(Bundesliga)
goals <- xtabs(~ AwayGoals + HomeGoals, data = Bundesliga, subset = Year == 1995)

data(HairEyeColor)
haireye <- xtabs(Freq ~ Hair + Eye, data = as.data.frame(HairEyeColor), subset = Sex == "Female")

data(UCBAdmissions)
ucb <- UCBAdmissions
dimnames(ucb)[[1]] <- c("Admit", "Reject")

data(Arthritis)
art <- xtabs(~ Improved + Treatment, data = Arthritis)
@

<<auxfunctions,echo=FALSE,results=hide>>=
he.test <- pearson.test(haireye, return = TRUE)
cb <- he.test$qdist(c(0.9, 0.99))

gp.shading <- function(x, y) gp.HSVshading(x, y, lty = 1, test = NULL)
shadeHSVchisq <- function(x, y) gp.HSVshading(x, y, lty = 1)
shadeHSVmax <- function(x, y) gp.HSVshading(x, y, interpolate = cb, lty = 1)
shadeHCLmax <- function(x, y) gp.HCLshading(x, y, interpolate = cb, lty = 1)
shadeHSVmax2 <- function(x, y) gp.HSVshading(x, y, interpolate = c(5,10), test = NULL)
shadeHCLchisq <- function(x, y) gp.HCLshading(x, y, lty = 1)

hue.slice <- function(hue, grid.n = 100, type = c("HCL", "HSV"), plot = TRUE, correct = FALSE)
{
  type <- match.arg(type)
  if(type == "HCL") {
    chroma = seq(0, 100, length = grid.n)
    luminance = seq(0, 100, length = grid.n)
    nc <- length(chroma)
    nl <- length(luminance)
    color.slice <- outer(chroma, luminance, function(y, x) hcl(hue, x, y, verbose = FALSE, correct = correct))
    xlab <- "chroma"
    ylab <- "luminance"
    main <- paste("hue =", round(hue, digits = 0))
  } else {
    chroma = seq(0, 1, length = grid.n)
    luminance = seq(0, 1, length = grid.n)
    nc <- length(chroma)
    nl <- length(luminance)
    color.slice <- outer(chroma, luminance, function(y, x) hsv(hue, x, y))
    xlab <- "saturation"
    ylab <- "value"
    main <- paste("hue =", round(hue, digits = 3))
  }
  if(plot) {
    plot(0.5, 0.5, xlim = range(chroma), ylim = range(luminance), type = "n", axes = FALSE,
         xlab = xlab, ylab = ylab, yaxs = "i", xaxs = "i", main = main)
    for(i in 1:(nc-1)) {
      rect(chroma[i], luminance[-nl], chroma[i] + 100/(nc-1), luminance[-1], border = color.slice[,i+1], col = color.slice[,i+1])
    }
    axis(1)
    axis(2)
    box()
  }
  colnames(color.slice) <- chroma
  rownames(color.slice) <- luminance
  attr(color.slice, "type") <- type
  class(color.slice) <- "slice"
  invisible(color.slice)
}

plot.slice <- function(color.slice)
{
  nc <- ncol(color.slice)
  nl <- nrow(color.slice)
  chroma <- as.numeric(colnames(color.slice))
  luminance <- as.numeric(rownames(color.slice))
  if(attr(color.slice, "type") == "HCL") {
    xlab <- "chroma"
    ylab <- "luminance"
  } else {
    xlab <- "saturation"
    ylab <- "value"
  }
  plot(0.5, 0.5, xlim = range(chroma), ylim = range(luminance), type = "n", axes = FALSE,
       xlab = xlab, ylab = ylab, yaxs = "i", xaxs = "i", main = deparse(substitute(color.slice)))
  for(i in 1:(nc-1)) {
    rect(chroma[i], luminance[-nl], chroma[i] + 100/(nc-1), luminance[-1], border = color.slice[,i+1], col = color.slice[,i+1])
  }
  axis(1)
  axis(2)
  box()
}
@


\begin{abstract}
Story starts out not from exploratory analysis with \proglang{R}
but from the problem of visualizing independence. Several
exploratory approaches but not combined with significance
testing.

Paper could be structured in the following way
\begin{itemize}
  \item Introduction
  \item Tests
  \item Data sets
  \item Visualization Techniques
    \begin{itemize}
      \item Mosaic displays
      \item Association plots
      \item Residuals-based shading
    \end{itemize}
  \item Extensions
    \begin{itemize}
      \item max-shading
      \item HCL colors
      \item conditional independence (coplots)
      \item \textit{not the implementation, just mention in summary}
    \end{itemize}
  \item Summary
\end{itemize}

The \proglang{R} side then has to be described in another paper,
probably for the Journal of Statistical Software.\\[0.3cm]
\textbf{Key Words:} Association plots; Conditional inference; 
  Contingency tables; Mosaic plots; Permutation tests.
\end{abstract}

\section{Introduction} \label{sec:introduction}

Statistical models built for the analysis of multivariate data
quickly become complex with increasing dimensionality.
One idea of visualization techniques is to
use the human visual system to detect structures in the data that
possibly are not obvious from solely numeric output (e.g., test
statistics).
The \textsf{R} package \texttt{vcd}---inspired by the Book ``Visualizing Categorical
Data'' \citep{vcd:Friendly:2000}---includes methods for the (mostly
graphical) exploration of categorical data, such as:
\begin{itemize}
 \item fitting and graphing of discrete distributions,
 \item plots and tests for independence and symmetry problems,
 \item visualization techniques for log-linear models.
\end{itemize}
Here, we focus on the visualization of independence,
in particular in 2-way tables.

\section{Tests for Independence in 2-way Tables} \label{sec:tests}

We consider a 2-way contingency table with cell frequencies $\{n_{ij}\}$ for
$i = 1, \dots, I$ and $j = 1, \dots, J$ and row and column sums
$n_{i+} = \sum_i n_{ij}$ and $n_{+j} = \sum_j n_{ij}$ respectively. For
convenience the number of observations is denoted $n = n_{++}$.

Given an underlying distribution with theoretical cell probabilities
$\pi_{ij}$, the null hypothesis of independence of the two categorical
variables can be formulated as
\begin{equation} \label{eq:H0}
H_0: \; \pi_{ij} \quad = \quad \pi_{i+} \pi_{+j}.
\end{equation}

The expected cell frequencies in this model are
$\hat n_{ij} = n_{i+}n_{+j}/n$. The best known and most used
measure of discrepancy
between observed and expected values are the Pearson residuals
\begin{equation} \label{eq:Pearson}
r_{ij} \quad = \quad \frac{n_{ij} - \hat n_{ij}}{\sqrt{\hat n_{ij}}}.
\end{equation}
Therefore, a rather intuitive idea is to reject the null hypothesis when
there are residuals which are too extreme, i.e., not close enough to
zero. The most convenient way to aggregate the $I \times J$ residuals
to one test statistic is their squared sum
\begin{equation} \label{eq:ChiSquare}
X^2 \quad = \quad \sum_{i, j}r_{ij}^2,
\end{equation}
because this is known to have a limiting $\chi^2$ distribution with $(I-1)(J-1)$
degrees of freedom under the null hypothesis.
This is the well-known $\chi^2$ test for independence in 2-way tables.
%% reference needed

But this is not the only plausible way of aggregation of the Pearson
residuals. There are many conceivable functionals $\lambda(\cdot)$ which
lead to reasonable test statistics $\lambda(\{r_{ij}\})$, the sum of squares
is just one of them. Another functional suitable for identifying
the cells which cause the dependence (if any) is the maximum of the absolute
values
\begin{equation} \label{eq:MaxAbs}
M \quad = \quad \max_{i, j} |r_{ij}|.
\end{equation}
Given a critical value $c_\alpha$ for this test statistic, all residuals whose
absolute value exceeds $c_\alpha$ violate the hypothesis of indendence at level
$\alpha$ \cite[][ch. 7]{vcd:Mazanec+Strasser:2000}. Thus, the interesting cells causing
the dependence can easily be identified.

Furthermore, the main reason for using the unconditional limiting distribution
for the $\chi^2$ statistic (\ref{eq:ChiSquare}) was the closed form result
for the distribution. Recently, with the improving perfomance of computers,
performing permutation tests---either by simulation or by computation of the
permutation distribution---became more and more popular. In particular for
the independence hypothesis (\ref{eq:H0}), using a permutation test is very intuitive
due to the permutation invariance (given row and column sums) of this problem.
By employing this approach the permutation distribution of statistics of
type $\lambda(\{r_{ij}\})$ (also including the $\chi^2$ statistic) can be derived.

Other classical tests for the hypothesis of independence  not fitting in
the Pearson residual-based framework described above include Fisher's exact test,
asymptotic tests of the odds ratio (for $2\times2$ tables) and the Mantel-Haenzel
test.


\section{Visualization Techniques for 2-way Tables} \label{sec:visualization}

The two best known visualization techniques for independence in 2-way tables are
association plots and mosaic plots. Both are suitable to bring out
departures of an observed table $(n_{ij})$ from the expected table $(\hat n_{ij})$ in a graphical way.
The former focuses on the visualization of the Pearson residuals $r_{ij}$ (under
independence) while the latter primarily displays the observed frequencies
$n_{ij}$.

\subsection{Association Plots}

Association plots \citep{vcd:Cohen:1980} visualize the table of Pearson residuals:
each cell is represented by a rectangle that has (signed) height
proportional to the corresponding Pearson residual $r_{ij}$ and width proportional to the
square root of the expected counts $\sqrt{\hat n_{ij}}$. Thus, the area is proportional to
the raw residuals $n_{ij} - \hat n_{ij}$. The sign of the residual is redundantly
coded by the rectangle's color and its position relative to the baseline.

Figure \ref{fig:goals-assoc-classic} shows the association plot for the table of
home and away goals for all 306 games in the 1995/6 season of the German soccer league
Bundesliga \citep[the data is available in the package \texttt{vcd}]{vcd:Knorr-Held:1999}.
In particular, it can be seen that there are
fewer games ending 1--0 and more ending 1--1 than would be expected under independence.
But this does not yet imply the significance of some test statistic.

\subsection{Mosaic Plots}

Mosaic plots can be seen as an extension of grouped
bar charts where width and height of the bars show the relative
frequencies of the two variables: a mosaic plot simply
consists of a collection of tiles whose
sizes are proportional to the observed cell frequencies
(see Figure \ref{fig:goals-mosaic-classic}).

Sequential horizontal and vertical recursive splits are used to
visualize the frequencies of more than two variables, each new variable
conditional to the previously entered variables. A first extension by
\cite{vcd:Friendly:1994} uses a color coding of the tiles to visualize deviations
(residuals) from a given log-linear model fitted to the table, that is, from
the expected frequencies under independence. This approach does not only work in 2-way
tables but also in log-linear models fitted to multi-way tables. In this
extension, positive and negative signs of the residuals are coded by rectangles with
solid and dashed borders respectively. Furthermore, residuals exceeding an absolute
value of 2 are shaded light blue and red respectively, those that even
exceed an absolute value of 4 are shaded with full saturation. The heuristic
behind this shading is that
the Pearson residuals are approximately standard normal which implies
that the highlighted cells are those with
residuals \emph{individually} significant at approximately the 5\% and 0.01\%
level. But the main purpose of the shading is not to visualize significance but the \emph{pattern} of
deviation from independence \citep[p.~109]{vcd:Friendly:2000}. In particular,
this shading does not provide a visualization of the maximum test (\ref{eq:MaxAbs})
as in general it is unknown to which significance level $\alpha$ the
values $c_\alpha = 2$ and $4$ correspond for the table being visualized.

Figure \ref{fig:goals-mosaic-classic} shows the Friendly mosaic plot for
the same Bundesliga data as in Figure \ref{fig:goals-assoc-classic}.
In this plot, the residuals
are visualized by the color shading of the cells. Again, the cells for
the 1--0 and 1--1 results are highlighted and furthermore, there seem to be
too many 6--3 results than would be plausible under independence. Whereas
the association plot in Figure \ref{fig:goals-assoc-classic} contains
no information about the result of a test for independence, the shading
in this plot conveys the impression that there might be
significant dependence (which would indicate that there
is not only {\em no} home field advantage in the German Bundesliga in 1995/6 but even
an advantage for the away team). However, it is unclear whether there
is evidence for this or not.

\section{Extensions} \label{sec:extensions}

In this section, we suggest some improvements and extensions which can be
applied to both visualization techniques introduced in Section
\ref{sec:visualization}. First, the visual enhancements
\begin{itemize}
\item combining visualization of and testing for independence
\item improved color schemes
\end{itemize}
are addressed. Second, the implementation enhancements
\begin{itemize}
\item more modular implementation using \texttt{grid}
\item more flexible plotting parameter specification
\end{itemize}
are described. None of these should be thought of as finished work
but rather as a collection of ideas which still need thorough
refinement and proper implementation.

\subsection{Visualization Enhancements}

The extensions of \cite{vcd:Friendly:1994} to mosaic plots provide
substantial improvement of the original mosaic plots and enhanced them
from a plot for contingency tables to a visualization technique for
log-linear models (and therefore also for certain independence problems).
However, it has two major drawbacks: First,
the significance level for the hard-coded critical values 2 and 4 is
usually unknown. Second, the colors for (light) blue and red
used in the Michael Friendly's \textsf{SAS} implementation and also in the base implementation
in \textsf{R} are not device-independent and
do not provide homogeneous saturations over different colors
and copier proofness. We suggest some ways to overcome these drawbacks.

As pointed out in Section \ref{sec:tests}, the critical values for
the maximum statistic $M$ from (\ref{eq:MaxAbs}) can be derived
from the permutation distribution. Instead of the hard-coded
values 2 and 4, the particular critical values, e.g., at the levels
$\alpha = 0.1$ and $0.01$, for the table to be visualized could be
used. Hence, exactly those residuals causing the (potential)
dependency within the table are highlighted. At the moment, these critical values
are derived in \texttt{vcd} by simulation of the underlying distribution.

The implementation of Friendly mosaic plots in \textsf{SAS}
uses (by default) colors in the HLS (Hue--Luminance--Saturation) color space
with hues for blue and red, full saturation, and varying luminance
for lighter colors. The current \textsf{R} implementation is
based on colors in the HSV (Hue--Saturation--Value) space where
decreasing the saturation from 1 towards 0
%% ---given the hue for blue or red and full saturation---
generates very similar colors
as increasing the luminance for HSL colors from 0.5 towards 1.
As an alternative to those HLS and HSV colors, the device-independent
HCL (Hue--Chroma--Luminance) color space \citep{vcd:Ihaka:2003} could be
used which also provides homogeneous saturations over different colors and copier
proofness. The resulting association plot (using critical values for
$\alpha = 0.1$ and $0.01$) for the Bundesliga data can be seen in
Figure \ref{fig:goals-assoc-signif}. It indicates very clearly that
there is no evidence for rejecting the hypothesis of independence
in this table. Thus, there seems to be neither an advantage for
the home team nor for the away team.

To illustrate what a `postive' example looks like we give the association plot
for the well-known Hair-Eye-Color data set (avilable in base \textsf{R}) which cross-tabulates the hair and eye
color and gender of 592 statistics students: Figure \ref{fig:haireye-assoc-signif}
shows the association plot for the 328 female students. It is easy to see that
the hypothesis of independence is rejected at 1\% level by the maximum test (\ref{eq:MaxAbs})
due to higher frequencies of students with hair and eye color
black/brown and blond/blue and lower frequencies of
blond/brown and brown/blue than would be plausible under independence. Furthermore,
it can also be seen that the residual corresponding to the black/blue
cell is significant at the 10\% level.

We have seen that this approach performs very well when the test statistic
which should be visualized is the maximum statistic (\ref{eq:MaxAbs}). However,
it is difficult to extend this approach to general tests for independence,
in particular in the HCL space, where the ranges of chroma and luminance are
not independent. In contrast the HSV space has the advantage that all
three dimensions hue, saturation and value have the range $[0,1]$ and can
be varied independently. Therefore, a different approach than the one
described above could be to use the hue for the sign of the residuals as
before, the saturation for the absolute size of the residuals, and the
value as an indicator for the significance of some test statistic (only
using the full value when the overall test for independence rejects
the null hypothesis). The resulting mosaic plots under this paradigm
are depicted in Figure \ref{fig:both-mosaic-signif}. Again, it can
clearly be seen that despite some large residuals there is no
evidence against independence for the Bundesliga data, but that the
null hypothesis has to be rejected for the Hair-Eye-Color data.


\subsection{Implementation Enhancements}

The current implementation of association and mosaic plots in \textsf{R} suffers
from two main disadvantages: First, it is not easy to recycle the
plots in conditioning plots or pairs plots (like mosaic matrices) as
they have been implemented using \textsf{R}'s base graphics engine where in
general plotting to relative coordinates is not supported.
The new implementation was written from scratch in \texttt{grid} offering
much more versatility amongst some minor advantages and convenient
improvements. Second, the graphics parameters of the rectangles in
association and mosaic plots (like in almost all standard \textsf{R}
plots), such as color and line type, cannot be specified for each cell
by the user. To overcome this the current implementation in \texttt{vcd}
allows the user to specify either arrays of graphics parameters
of the same dimensionality as the object being plotted or a function
which computes these graphics parameters based on the original table
and its Pearson residuals. Functions are provided for the shading schemes
described in the previous section. Without this feature we would not be
able to specify the shading schemes described in the previous section
in such a flexible way.


\section{Multi-way Tables}

Independence problems do not only occur in 2-way tables, although that
is an important special case, but they are also important in tables of
higher dimensionality and can follow much more complex patterns.
These are again defined based on the underlying table of theoretical cell probabilities
$(\pi_{ij\dots})$ with more than two dimensions. Models of interest include the
null hypotheses of:
\begin{itemize}
 \item total independence:
  $\pi_{ijk\dots} = \pi_{i++\dots}\pi_{+j+\dots}\pi_{++k\dots}\dots$
 \item conditional independence:
  $\pi_{ijk\dots} = \pi_{i|k\dots}\pi_{j|k\dots}$
 \item joint independence:
  $\pi_{ijk\dots} = \pi_{ij+\dots}\pi_{++k\dots}$
\end{itemize}
Classical non-graphical methods for these problems include the $\chi^2$
test, Fisher's exact test, the Cochran-Mantel-Haenzel test (for $2 \times 2 \times
K$-tables), and the analysis of log-linear models for more
complex settings.

As an example, two natural ways to use the visualization techniques described in the previous
sections would be to use (Trellis-like) conditioning plots or pairs plots
(like mosaic matrices) to visualize these more complex patterns of
independence.

Two ideas for the problem of conditional independence are briefly outlined
here and illustrated using the famous admissions data of the University of
California at Berkley (UCB) which is available in base \textsf{R}.
In this data, the question whether there is gender
discrimination at the UCB leads to the result that although women seem to
be disadvantaged at the aggregated level there is no gender discrimination
conditioned on the department---with the very exception of one department
in which women are {\em more} likely to be admitted than would be plausible
under independence. Exactly this is illustrated in the conditioning
assocation plot in Figure \ref{fig:UCB-assoc-signif}.

Similarly, the same data can be visualized using a mosaic matrix where
a conditional independence model is fitted in each plot (see Figure
\ref{fig:UCB-mosaic-signif}).


\section{Conclusions}
We suggest a set of enhancements for visualizing the independence
problem in 2-way tables with some outlook to multi-way tables. The
extensions aim at improving the visualization by displaying both
the size of the residuals and the significance of a test for
independence and by using better color schemes. Furthermore, a new
implementation is outlined based on the graphics package \texttt{grid}
which provides more modular design and more flexible specification
of graphical parameters.


\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}[htbp]
\begin{center}
<<goals-assoc-classic,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.assocplot(goals, rot = 0, gp = gp.binary)
@
<<goals-mosaic-classic,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
mosaicplot(t(goals), shade = TRUE, main = "")
@
\caption{Classic association and mosaic plot for the Bundesliga data.}
\label{fig:goals-assoc-classic}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
<<haireye-Friendly,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(haireye, gp = gp.Friendly)
@
<<haireye-max,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(haireye, gp = gp.max)
@
\caption{Mosaic plots for the Hair-Eye-Color data.}
\label{fig:haireye}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<goals-Friendly,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(goals, gp = gp.Friendly)
@
<<goals-max,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(goals, gp = gp.max)
@
\caption{Mosaic plots for the Bundesliga data.}
\label{fig:goals}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<art-Friendly,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(art, gp = gp.Friendly)
@
<<art-max,fig=TRUE,echo=FALSE,height=6,width=7,results=hide>>=
grid.mosaicplot(art, gp = gp.max)
@
\caption{Mosaic plots for the Arthritis data.}
\label{fig:art}
\end{center}
\end{figure}


\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[htbp]
\begin{center}
<<Friendly-hue,fig=TRUE,echo=FALSE,height=4.8,width=8>>=
plot(0.5, 0.5, xlim = c(0, 1), ylim = c(0, 1), type = "n", axes = FALSE, xlab = "", ylab = "", yaxs = "i")
dummy <- 0:100/100
dummy.col <- hsv(dummy[-101] + 1/200, 1, 1)
rect(dummy[-101], 0.6, dummy[-1], 1, border = dummy.col, col = dummy.col)
rect(0, 0.6, 1, 1)
axis(3)
mtext("hue", line = 2, cex = 1.5)
text(1, 0.45, "saturation = 1\nvalue = 1", pos = 2, cex = 1.2)
lines(c(0.1, 0), c(0.3, 0.6), lty = 2)
lines(c(2/3, 2/3), c(0.3, 0.6), lty = 2)
rect(0, 0.1, 0.2, 0.3, col = hsv(0, 1, 1))
rect(2/3 - 0.1, 0.1, 2/3 + 0.1, 0.3, col = hsv(2/3, 1, 1))
text(0.1, 0.1, expression(r[ij] < 0), pos = 1, cex = 1.5)
text(2/3, 0.1, expression(r[ij] > 0), pos = 1, cex = 1.5)
@

<<Friendly-sat,fig=TRUE,echo=FALSE,height=4.8,width=8>>=
plot(0.5, 0.5, xlim = c(0, 1), ylim = c(0, 1), type = "n", axes = FALSE, xlab = "", ylab = "", yaxs = "i")
dummy <- 0:100/100
dummy.col <- hsv(2/3, dummy[-101] + 1/200, 1)
rect(dummy[-101], 0.8, dummy[-1], 1, border = dummy.col, col = dummy.col)
dummy.col <- hsv(0, dummy[-101] + 1/200, 1)
rect(dummy[-101], 0.6, dummy[-1], 0.8, border = dummy.col, col = dummy.col)
rect(0, 0.8, 1, 1)
rect(0, 0.6, 1, 0.8)
axis(3)
mtext("saturation", line = 2, cex = 1.5)
mtext(c("h = 0", "h = 2/3"), side = 2, at = c(0.7, 0.9), las = 1, cex = 1.2)
text(0.8, 0.5, "value = 1", pos = 2, cex = 1.2)
lines(c(0.1, 0), c(0.3, 0.6), lty = 2)
lines(c(0.5, 0.5), c(0.3, 0.6), lty = 2)
lines(c(0.9, 1), c(0.3, 0.6), lty = 2)
rect(0, 0.2, 0.2, 0.3, col = hsv(2/3, 0, 1))
rect(0, 0.1, 0.2, 0.2, col = hsv(0, 0, 1))
rect(0.4, 0.2, 0.6, 0.3, col = hsv(2/3, 0.5, 1))
rect(0.4, 0.1, 0.6, 0.2, col = hsv(0, 0.5, 1))
rect(0.8, 0.2, 1, 0.3, col = hsv(2/3, 1, 1))
rect(0.8, 0.1, 1, 0.2, col = hsv(0, 1, 1))
text(0.1, 0.1, expression(abs(r[ij]) < 2), pos = 1, cex = 1.5)
text(0.5, 0.1, expression(2 < abs(r[ij]) < 4), pos = 1, cex = 1.5)
text(0.9, 0.1, expression(abs(r[ij]) > 4), pos = 1, cex = 1.5)
@

<<Friendly-val,fig=TRUE,echo=FALSE,height=4.8,width=8>>=
plot(0.5, 0.5, xlim = c(0, 1), ylim = c(0, 1), type = "n", axes = FALSE, xlab = "", ylab = "", yaxs = "i")
dummy <- 0:100/100
dummy.col <- hsv(2/3, 1, dummy[-101] + 1/200)
rect(dummy[-101], 0.8, dummy[-1], 1, border = dummy.col, col = dummy.col)
dummy.col <- hsv(0, 1, dummy[-101] + 1/200)
rect(dummy[-101], 0.6, dummy[-1], 0.8, border = dummy.col, col = dummy.col)
rect(0, 0.8, 1, 1)
rect(0, 0.6, 1, 0.8)
axis(3)
mtext("value", line = 2, cex = 1.5)
mtext(c("h = 0", "h = 2/3"), side = 2, at = c(0.7, 0.9), las = 1, cex = 1.2)
text(0, 0.5, paste("saturation =", 1), pos = 4, cex = 1.2)
lines(c(0.85, 1), c(0.3, 0.6), lty = 2)
rect(0.7, 0.2, 0.8, 0.3, col = hsv(2/3, 0, 1))
rect(0.8, 0.2, 0.9, 0.3, col = hsv(2/3, 0.5, 1))
rect(0.9, 0.2, 1, 0.3, col = hsv(2/3, 1, 1))
rect(0.7, 0.1, 0.8, 0.2, col = hsv(0, 0, 1))
rect(0.8, 0.1, 0.9, 0.2, col = hsv(0, 0.5, 1))
rect(0.9, 0.1, 1, 0.2, col = hsv(0, 1, 1))
lines(c(0.5, 0.5), c(0.3, 0.6), lty = 2)
lines(c(0.85, 1), c(0.3, 0.6), lty = 2)
rect(0.35, 0.2, 0.45, 0.3, col = hsv(2/3, 0, 0.5))
rect(0.45, 0.2, 0.55, 0.3, col = hsv(2/3, 0.5, 0.5))
rect(0.55, 0.2, 0.65, 0.3, col = hsv(2/3, 1, 0.5))
rect(0.35, 0.1, 0.45, 0.2, col = hsv(0, 0, 0.5))
rect(0.45, 0.1, 0.55, 0.2, col = hsv(0, 0.5, 0.5))
rect(0.55, 0.1, 0.65, 0.2, col = hsv(0, 1, 0.5))
rect(0.7, 0.2, 0.8, 0.3, col = hsv(2/3, 0, 1))
rect(0.8, 0.2, 0.9, 0.3, col = hsv(2/3, 0.5, 1))
rect(0.9, 0.2, 1, 0.3, col = hsv(2/3, 1, 1))
rect(0.7, 0.1, 0.8, 0.2, col = hsv(0, 0, 1))
rect(0.8, 0.1, 0.9, 0.2, col = hsv(0, 0.5, 1))
rect(0.9, 0.1, 1, 0.2, col = hsv(0, 1, 1))
text(0.5, 0.1, "non-significant", pos = 1, cex = 1.5)
text(0.85, 0.1, "significant", pos = 1, cex = 1.5)
@

\caption{Extended Friendly shading in HSV space.}
\label{fig:Friendly-HSV}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<Friendly-HSV,fig=TRUE,echo=FALSE,height=7,width=8>>=
## generate colors
hue23 <- hue.slice(2/3, grid.n = 101, plot = FALSE, type = "HSV")
hue0 <- hue.slice(0, grid.n = 101, plot = FALSE, type = "HSV")
mysaturation <- as.numeric(colnames(hue23))
value <- as.numeric(rownames(hue23))

## select those with value >= 0.5
hue23 <- hue23[value >= .5, ]
hue0 <- hue0[value >= .5, ]
value <- value[value >= .5]
nl <- nrow(hue23)
nc <- ncol(hue23)

## plot 2 slides from HSV space
plot(0.5, 0.5, xlim = c(-1, 1), ylim = c(0, 1), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
for(i in 1:(nc-1)) {
  rect(mysaturation[i], value[-nl], mysaturation[i] + 1/(nc-1), value[-1], border = hue23[,i+1], col = hue23[,i+1])
}
for(i in 1:(nc-1)) {
  rect(-mysaturation[i], value[-nl], -(mysaturation[i] + 1/(nc-1)), value[-1], border = hue0[,i+1], col = hue0[,i+1])
}
axis(2, at = c(50, 75, 100)/100, labels = c(0.5, 0.75, 1))
axis(4, at = c(50, 75, 100)/100, labels = c(0.5, 0.75, 1))
axis(3, at = -4:4*.25, labels=c(4:0*.25, 1:4*.25))
mtext(c("hue = 0", "hue = 2/3"), side = 3, at = c(-.5, .5), line = 3, cex = 1.2)
mtext("saturation", side = 3, at = 0, line = 2)
mtext("value", side = 2, at = .75, line = 2)
mtext("value", side = 4, at = .75, line = 2)
lines(c(-1, 1), c(.5, .5))

## significant colors
rect(-1, 0.95, -.90, 1, col = hsv(0, 1, 1))
rect(-0.45, 0.95, -.55, 1, col = hsv(0, 0.5, 1))
rect(-.05, .95, .05, 1, col = hsv(2/3, 0, 1))
rect(0.45, 0.95, .55, 1, col = hsv(2/3, 0.5, 1))
rect(.90, .95, 1, 1, col = hsv(2/3, 1, 1))

text(-1, .33, "significant", pos = 4, cex = 1.2)
rect(-1, .20, -.80, .30, col = hsv(0, 1, 1))
rect(-.40, .20, -0.6, .30, col = hsv(0, 0.5, 1))
rect(-.20, .20, 0, .30, col = hsv(0, 0, 1))
rect(0, .20, .20, .30, col = hsv(2/3, 0, 1))
rect(0.4, .20, .60, .30, col = hsv(2/3, .5, 1))
rect(.80, .20, 1, .30, col = hsv(2/3, 1, 1))

lines(c(-.9, -.55), c(0.975, .975), lty = 2)
lines(c(-.45, -.05), c(0.975, .975), lty = 2)
lines(c(.45, .05), c(0.975, .975), lty = 2)
lines(c(.9, .55), c(0.975, .975), lty = 2)

## non-significant colors
rect(-1, 0.5, -.90, 0.55, col = hsv(0, 1, 0.5))
rect(-0.45, 0.5, -.55, 0.55, col = hsv(0, 0.5, 0.5))
rect(-.05, .5, .05, 0.55, col = hsv(2/3, 0, 0.5))
rect(0.45, 0.5, .55, 0.55, col = hsv(2/3, 0.5, 0.5))
rect(.90, .5, 1, 0.55, col = hsv(2/3, 1, 0.5))

text(-1, .13, "non-significant", pos = 4, cex = 1.2)
rect(-1, 0, -.80, .10, col = hsv(0, 1, 0.5))
rect(-.60, 0, -.4, .10, col = hsv(0, 0.5, 0.5))
rect(-.20, 0, 0, .10, col = hsv(0, 0, 0.5))
rect(0, 0, .20, .10, col = hsv(2/3, 0, 0.5))
rect(0.4, 0, .60, .1, col = hsv(2/3, .5, 0.5))
rect(.80, 0, 1, .10, col = hsv(2/3, 1, 0.5))

lines(c(-.9, -.55), c(0.525, .525), lty = 2)
lines(c(-.45, -.05), c(0.525, .525), lty = 2)
lines(c(.45, .05), c(0.525, .525), lty = 2)
lines(c(.9, .55), c(0.525, .525), lty = 2)
@

<<HCL-space,fig=TRUE,echo=FALSE,height=7,width=8>>=
## generate colors
hue260 <- hue.slice(260, grid.n = 101, plot = FALSE)
hue360 <- hue.slice(360, grid.n = 101, plot = FALSE)
mychroma <- as.numeric(colnames(hue260))
luminance <- as.numeric(rownames(hue260))

## select those with lumincance >= 50
hue260 <- hue260[luminance >= 50, ]
hue360 <- hue360[luminance >= 50, ]
luminance <- luminance[luminance >= 50]
nc <- ncol(hue260)
nl <- nrow(hue260)

## plot 2 slides from HCL space
plot(0.5, 0.5, xlim = c(-100, 100), ylim = c(0, 100), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
for(i in 1:(nc-1)) {
  rect(mychroma[i], luminance[-nl], mychroma[i] + 100/(nc-1), luminance[-1], border = hue260[,i+1], col = hue260[,i+1])
}
for(i in 1:(nc-1)) {
  rect(-mychroma[i], luminance[-nl], -(mychroma[i] + 100/(nc-1)), luminance[-1], border = hue360[,i+1], col = hue360[,i+1])
}
axis(2, at = c(50, 75, 100), labels = c(50, 75, 100))
axis(4, at = c(50, 75, 100), labels = c(50, 75, 100))
axis(3, at = -4:4*25, labels=c(4:0*25, 1:4*25))
mtext(c("hue = 0", "hue = 260"), side = 3, at = c(-50, 50), line = 3, cex = 1.2)
mtext("chroma", side = 3, at = 0, line = 2)
mtext("luminance", side = 2, at = 75, line = 2)
mtext("luminance", side = 4, at = 75, line = 2)
lines(c(-100, 100), c(50, 50))

## significant colors
rect(-100, 47.5, -90, 52.5, col = hcl(0, 100, 50))
rect(-55, 67.5, -45, 72.5, col = hcl(0, 50, 70))
rect(-5, 95, 5, 100, col = hcl(260, 0, 100))       ## grey vs. white
rect(-5, 87.5, 5, 92.5, col = hcl(260, 0, 90))     ## grey vs. white
rect(45, 67.5, 55, 72.5, col = hcl(260, 50, 70))
rect(90, 47.5, 100, 52.5, col = hcl(260, 100, 50))

text(-100, 33, "significant", pos = 4, cex = 1.2)
rect(-100, 20, -80, 30, col = hcl(0, 100, 50))
rect(-60, 20, -40, 30, col = hcl(0, 50, 70))
rect(-20, 20, 0, 30, col = hcl(0, 0, 90))       
rect(0, 20, 20, 30, col = hcl(260, 0, 90))
#white# rect(-20, 20, 0, 30, col = hcl(0, 0, 100))
#white# rect(0, 20, 20, 30, col = hcl(260, 0, 100))
rect(40, 20, 60, 30, col = hcl(260, 50, 70))
rect(80, 20, 100, 30, col = hcl(260, 100, 50))

lines(c(-45, -5), c(72.5, 87.5), lty = 2)
lines(c(45, 5), c(72.5, 87.5), lty = 2)
lines(c(-95, -55), c(52.5, 67.5), lty = 2)
lines(c(95, 55), c(52.5, 67.5), lty = 2)

## non-significant colors
rect(-25, 47.5, -15, 52.5, col = hcl(0, 20, 50))
rect(-15, 67.5, -5, 72.5, col = hcl(0, 10, 70))
rect(5, 67.5, 15, 72.5, col = hcl(260, 10, 70))
rect(25, 47.5, 15, 52.5, col = hcl(260, 20, 50))


text(-100, 13, "non-significant", pos = 4, cex = 1.2)
rect(-60, 0, -40, 10, col = hcl(0, 20, 50))
rect(-40, 0, -20, 10, col = hcl(0, 10, 70))
rect(-20, 0, 0, 10, col = hcl(0, 0, 90))
rect(0, 0, 20, 10, col = hcl(260, 0, 90))
rect(20, 0, 40, 10, col = hcl(260, 10, 70))
rect(40, 0, 60, 10, col = hcl(260, 20, 50))

lines(c(-18.75, -11.25), c(52.5, 67.5), lty = 2)
lines(c(-8.75, -1.25), c(72.5, 87.5), lty = 2)
lines(c(18.75, 11.75), c(52.5, 67.5), lty = 2)
lines(c(8.75, 1.25), c(72.5, 87.5), lty = 2)
@
\caption{Extended shading in HSV and HCL space.}
\label{fig:ExtHSVHCL}
\end{center}
\end{figure}


\setkeys{Gin}{width=\textwidth}
\begin{figure}[htbp]
\begin{center}
<<UCB-mosaic1,fig=TRUE,echo=FALSE,height=4,width=8>>=
fm <- loglm(~(Gender + Admit)*Dept, data = UCBAdmissions, fitted = TRUE)
res.fm <- (UCBAdmissions - fitted(fm))/sqrt(fitted(fm))
dim(res.fm) <- dim(UCBAdmissions)
my.gp <- gp.HCLshading(UCBAdmissions, aperm(res.fm))
my.gp$p.value <- summary(fm)$tests[2,3]
my.gp$lty <- c(1,1)
grid.mosaicplot(ucb, gp = my.gp, margin = ~ (Gender + Admit)*Dept, space = c(0.1, 0.01, 0))
@
\caption{UCB admission with mosaic display.}
\label{fig:UCB-mosaic1}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<UCB-mosaic2,fig=TRUE,echo=FALSE,height=6,width=8>>=
mygp.max <- function(x,y) gp.max(x, y, level = (1 - c(0.1, 0.01)/6))
tabplot(ucb, panel = function(x, ...) grid.mosaicplot(x, panel = TRUE, legend = FALSE, labels = FALSE, gp = mygp.max, space = 0.02, ...))
@
\caption{UCB admission with conditioned mosaic display.}
\label{fig:UCB-mosaic2}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<UCB-assoc,fig=TRUE,echo=FALSE,height=8,width=8>>=
tabplot(margin.table(ucb, c(2,1,3)), gp = mygp.max)
@
\caption{UCB admission with conditioned association plot.}
\label{fig:UCB-assoc}
\end{center}
\end{figure}



\nocite{*}
\bibliography{vcd}

\end{document}

