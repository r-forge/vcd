\documentclass[a4paper]{article}
\usepackage{hyperref, graphicx, color, alltt, a4wide}
\usepackage{Sweave}
\usepackage[round]{natbib}
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}
\definecolor{hellgrau}{rgb}{0.55,0.55,0.55}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\var}[1]{\textit{\texttt{#1}}}
\newenvironment{smallexample}{\begin{alltt}}{\end{alltt}}

%% \code without `-' ligatures
{\catcode`\-=\active%
  \global\def\code{\bgroup%
    \catcode`\-=\active \let-\codedash%
    \Rd@code}}
\def\codedash{-\discretionary{}{}{}}
\def\Rd@code#1{\texttt{#1}\egroup}

\begin{document}

%\VignetteIndexEntry{Labeling in Strucplots}
%\VignetteDepends{vcd}
%\VignetteKeywords{graphics, categorical data}
%\VignettePackage{vcd}

\SweaveOpts{engine=R,eps=TRUE,height=6,width=7,results=hide,fig=FALSE,echo=TRUE}
\setkeys{Gin}{width=0.7\textwidth}

<<preliminaries,echo=FALSE>>=
options(width=70)
set.seed(1071)
library(vcd)
data(Titanic)
@

\title{Labeling in Strucplots}
\author{by David Meyer\\
  Wirtschaftsuniversit\"at Wien, Austria\\
\url{David.Meyer@R-project.org}
}
\maketitle
\sloppy

One of the major enhancements in \pkg{vcd} compared to
\code{mosaicplot()} and \code{assocplot()} in
base {\sf R} is the labeling of strucplots which now
has become much more powerful and flexible. Like the panel, the
shading, the spacing, and the legend, labeling is now completely modular.
The user supplies either a labeling function, or, alternatively, 
a generating function that parameterizes a labeling function, 
to \code{strucplot()} which then draws the labels. The labeling is 
well-separated from the actual plotting that occurs in the panel functions;
it actually only relies on the viewport tree produced by them, and the
`dimnames' attribute of the visualized table. The drawing of the
labels happens after the actual plot has been drawn by the panel function.
Thus, it is possible to supply one's own labeling function, or
to combine some of the basic functions to produce a more complex labeling.
As an example, consider \code{labeling\_list()}:

\begin{Sinput}
labeling_list <- function(gp = gpar(), just = "left", pos = "left", lsep = ": ", 
                          sep = " ", offset = unit(c(2, 2), "lines"),
                          varnames = TRUE, cols = 2, ...) 
  function(d, split_vertical, condvars) {
    \dots
  }
\end{Sinput}

\code{labeling\_list()} is a generating function that takes all parameters
as arguments, and returns the actual labeling function which takes
only three arguments: the dimnames structure of the table, the logical
vector with the splitting information, and the number of conditioning
variables (if any). The labeling function has access to the arguments
of the generating function because in {\sf R}, nested functions are
lexically scoped. In the
following, we describe the three basic modules
(\code{labeling\_text()}, \code{labeling\_list()}, and \code{labeling\_cells()}) and
derived functions that build upon them.

\section{Labels in the borders: \texttt{labeling\_text()}}

\code{labeling\_text()} is the default for all strucplot displays. It
plots labels in the borders similar to the \code{mosaicplot()}
function in base {\sf R}, but is much more flexible: it is not limited
to 4 dimensions, and the positioning and graphical parameters 
of levels and variable names are quite customizable. In addition,
the problem of overlapping labels can be handled in several ways. 

As an example, consider the `Titanic' data, consisting
of 4 categorical variables: Survived, Sex (i.e., `Gender'), Age, and
Crew. By default, the variable names and levels are plotted `around' the
plot in a counter-clockwise way (see Figure \ref{fig:defaults}):

<<default>>=
mosaic(Titanic)
@

\begin{figure}[h]
\begin{center}
<<defaultfig,fig=TRUE,echo=FALSE>>=
<<default>>
@
\caption{Mosaic plot for the Titanic data.}
\label{fig:defaults}
\end{center}
\end{figure}

\noindent Note that the last two levels of the `Survived' variable do
overlap, as well as some `Adult' and `Child' labels of the `Age' Variable.
This issue can be addressed in several ways. The `brute force'
method is to enable clipping for these dimensions (see Figure \ref{fig:clipping}):

<<clipping>>=
mosaic(Titanic, labeling_args = list(clip = c(Survived = TRUE, Age = TRUE)))
@

\begin{figure}[h]
\begin{center}
<<clippingfig,fig=TRUE,echo=FALSE>>=
<<clipping>>
@
\caption{The effect of clipping.}
\label{fig:clipping}
\end{center}
\end{figure}

\noindent The \code{clip} parameter is passed to the labeling function
via the \code{labeling\_args} argument which takes a list of
parameters. \code{clip} itself takes a vector of logicals (one for
each dimension). Almost all vectorized arguments in the strucplot
framework can be abbreviated in the following way: unnamed components
(or the defaults, if there are none) are recycled as needed, but
overridden by the named components. Here, the default is \code{FALSE},
and therefore clipping is enabled only for the `Survived' and `Age' dimensions.
A more sensible solution to the overlap problem is to abbreviate the 
levels (see Figure \ref{fig:abbreviating}):

<<abbreviating>>=
mosaic(Titanic, labeling_args = list(abbreviate = c(Survived = TRUE, Age = 4)))
@

\begin{figure}[h]
\begin{center}
<<abbreviatingfig,fig=TRUE,echo=FALSE>>=
<<abbreviating>>
@
\caption{Abbreviating.}
\label{fig:abbreviating}
\end{center}
\end{figure}

\noindent The \code{abbreviate} argument takes a vector of
integers indicating the number of significant characters the levels should be
abbreviated to (\code{TRUE} is interpreted as 1, obviously). Abbreviation
is performed using {\sf R}'s \code{abbreviate()} function. Another
possibility is to rotate the levels (see Figure \ref{fig:rotating}):

<<rotate>>=
mosaic(Titanic, labeling_args = list(rot_labels = c(bottom = 90, right = 0)),
                margins = c(right = 6, bottom = 4))
@

\begin{figure}[h]
\begin{center}
<<rotatefig,fig=TRUE,echo=FALSE>>=
<<rotate>>
@
\caption{Rotating labels.}
\label{fig:rotating}
\end{center}
\end{figure}

\noindent Finally, we could also inhibit the output of repeated levels 
(see Figure \ref{fig:repeat}):

<<repeat>>=
mosaic(Titanic, labeling_args = list(rep = c(Survived = FALSE, Age = FALSE)))
@

\begin{figure}[h]
\begin{center}
<<repeatfig,fig=TRUE,echo=FALSE>>=
<<repeat>>
@
\caption{Inhibiting the repetition of levels.}
\label{fig:repeat}
\end{center}
\end{figure}

We now proceed with a few more `cosmetic' features.
A first simple, but effectful modification is to position
all labels and variables left-aligned, which can
also be achieved by using \code{labeling\_left()} (see Figure \ref{fig:left}):

<<left>>=
mosaic(Titanic, labeling_args = list(pos_varnames = "left", pos_labels = "left", 
       just_labels = "left", rep = FALSE))
@

\begin{figure}[h]
\begin{center}
<<leftfig,fig=TRUE,echo=FALSE>>=
<<left>>
@
\caption{Left-aligning.}
\label{fig:left}
\end{center}
\end{figure}

\noindent Note that obviously we need to change the justification to \code{"left"} as well. Next, we show how to put all levels to the
bottom and right margins, and all variable names to the top and left
margins (see Figure \ref{fig:margins}):

<<margins>>=
mosaic(Titanic, labeling_args = list(tl_labels = FALSE, tl_varnames = TRUE, abbreviate = c(Survived = 1, Age = 4)))
@

\begin{figure}[h]
\begin{center}
<<marginsfig,fig=TRUE,echo=FALSE>>=
<<margins>>
@
\caption{Changes in the margins.}
\label{fig:margins}
\end{center}
\end{figure}

\noindent The \var{tl\_foo} (``top left'') arguments are \code{TRUE} by default. 
Now, we will add boxes to the labels and additionally
enable clipping (see Figure \ref{fig:boxes}):

<<boxes>>=
mosaic(Titanic, labeling_args = list(tl_labels = FALSE, tl_varnames = TRUE, 
       boxes = TRUE, clip = TRUE))
@

\begin{figure}[h]
\begin{center}
<<boxesfig,fig=TRUE,echo=FALSE>>=
<<boxes>>
@
\caption{Boxes and Clipping.}
\label{fig:boxes}
\end{center}
\end{figure}

\noindent The values to \code{boxes} and \code{clip} are recycled for
all dimensions. The result is pretty close to what the \code{labels\_cboxed()}
wrapper does. Another variant is to put the variable names into the
same line as the levels (see Figure \ref{fig:labbl}):

<<labbll>>=
mosaic(Titanic, labeling_args = list(tl_labels = TRUE, boxes = TRUE, clip = TRUE, 
       labbl_varnames = TRUE), margins = c(left = 4, right = 1, 3))
@

\begin{figure}[h]
\begin{center}
<<labbllfig,fig=TRUE,echo=FALSE>>=
<<labbll>>
@
\caption{Variable names beneath levels.}
\label{fig:labbl}
\end{center}
\end{figure}

\noindent \code{labbl\_varnames} (``variable names to the bottom/left of the
labels'') is a vector of logicals indicating the side for the
variable names. The resulting layout is basically what \code{labeling\_lboxed()} produces,
and a similar design is used by the \code{doubledecker()}.

\section{Labels in the cells: \texttt{labeling\_cells()}}

This labeling draws both variable names and levels in the
cells. As an example, we use the `PreSex' data on pre- and
extramarital sex and divorce (see Figure \ref{fig:cell}):

<<cell>>=
mosaic(~ MaritalStatus + Gender, data = PreSex, labeling = labeling_cells)
@

\begin{figure}[h]
\begin{center}
<<cellfig,fig=TRUE,echo=FALSE>>=
<<cell>>
@
\caption{Cell labeling for the `PreSex' data.}
\label{fig:cell}
\end{center}
\end{figure}

\noindent In the case of narrow cells, it might be useful to
abbreviate labels and/or variable names and turn off clipping (see Figure \ref{fig:cell2}):

<<cell2>>=
mosaic(~ PremaritalSex + ExtramaritalSex, data = PreSex, 
labeling = labeling_cells(abbreviate_labels = TRUE, abbreviate_varnames = TRUE, clip = FALSE))
@

\begin{figure}[h]
\begin{center}
<<cell2fig,fig=TRUE,echo=FALSE>>=
<<cell2>>
@
\caption{Cell labeling for the `PreSex' data, labels abbreviated.}
\label{fig:cell2}
\end{center}
\end{figure}

\noindent For some data, it might be convenient to combine cell
labeling with border labeling as done by \code{labels\_conditional()}
(see Figure \ref{fig:conditional}):

<<conditional>>=
mosaic(~ PremaritalSex + ExtramaritalSex | MaritalStatus + Gender, data = PreSex, labeling = labeling_conditional(abbreviate_varnames = TRUE, abbreviate_labels = TRUE))
@

\begin{figure}[h]
\begin{center}
<<conditionalfig,fig=TRUE,echo=FALSE>>=
<<conditional>>
@
\caption{Conditional labeling for the `PreSex' data, labels abbreviated.}
\label{fig:conditional}
\end{center}
\end{figure}

\noindent Additionally, the cell labeling allows the user to add
arbitrary text to the cells by supplying a character array in the same
shape than the data array to the \code{text} argument (cells with missing values
are ignored). In the following example, this is used to add all observed values greater
than 5 to the cells after the mosaic for the `Titanic' data has been plotted
(see Figure \ref{fig:text}):

<<text>>=
mosaic(Titanic, pop = FALSE, labeling_args = list(abbreviate = c(Survived = 1, Age = 4)))

tab <- ifelse(Titanic < 6, NA, Titanic)
labeling_cells(text = tab, clip = FALSE)(Titanic)
@

\begin{figure}[h]
\begin{center}
<<textfig,fig=TRUE,echo=FALSE>>=
<<text>>
@
\caption{User-supplied Text added to a mosaic display of the `Titanic' data.}
\label{fig:text}
\end{center}
\end{figure}

\section{A simple list of labels:\texttt{labels\_list()}}

If problems with overlapping labels cannot satisfactorily resolved,
the last remedy could be to simply list the levels below the plot
(see Figure \ref{fig:list}):

<<list>>=
mosaic(Titanic, labeling = labeling_list, margins = c(bottom = 5))
@

\begin{figure}[h]
\begin{center}
<<listfig,fig=TRUE,echo=FALSE>>=
<<list>>
@
\caption{Labels indicated below the plot.}
\label{fig:list}
\end{center}
\end{figure}

\noindent The number of columns can be specified.

\end{document}

